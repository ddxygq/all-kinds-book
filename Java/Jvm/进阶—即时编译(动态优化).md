[toc]
## 即时编译
- Just-In-Time，即时编译
- 通常而言，代码会先被JVM解释执行，之后反复执行的热点代码，则会被即时编译成机器码，直接运行在底层硬件之上。

### 分层编译模式
- Java 8 默认开启了分层编译。
- 结合了C1的启动性能优势和C2的峰值性能优势。
- 通常情况下，C2机器码比C1机器码的执行效率高出30%以上。
- 如果C1、C2编译了方法，并且未失效，那么JVM是不会再次发出该方法的编译请求。
- JVM 会将编译线程按照1:2的比例分配给C1和C2，启动分层编译的阈值是动态调整的。

### OSR 编译
- 决定一个方法是否为热点代码的因素有两个，方法的调用次数、循环回边的执行次数（例如for循环的次数），即时编译就是**根据这两个计数器的和来触发**。
- 程序执行过程中，动态替换掉Java方法栈帧，从而使得程序能够在非方法入口处**进行解释执行和编译后的代码之间的切换**。默认情况C1的 OSR 编译的阈值为13500，C2为10700.
- 函数要么解释，要么编译执行。从解释切换到机器码执行，如果尚未准备好编译版本，则解释执行，下次才机器码执行。绝大部分场合适用。

### 方法内联
- 在编译过程中遇到方法调用时，**将目标方法的方法纳入编译范围之中，并取代原方法调用的优化手段**。
- 减少方法调用的次数，提高性能。JIT编译器默认开启

##### 使用
1. "-XX:+Inline"：开启方法内联优化。
2. "-XX:FreqInlineSize"：内联体积上限，方法体积大于该值则不内联。

#### 优势
- 　方法内联可以**消除调用本身带来的开销**，还可以进一步出发更多的优化。
- 内联越多，生成代码的执行效率越高。
- 然而对于即时编译器来说，内联越多，编译时间也就越长，而程序达到峰值的时刻也将被推迟。也会导致生成的机器码越长。

#### 内联规则
### 代码缓存
- Code Cache。保存字节码被编译后的机器码，缓存用完后JIT编译停止，后续未编译的字节码解释执行。代码缓存的清理也由GC完成。
- "-XX:ReservedCodeCacheSize"指定缓存大小，默认32MB
## 虚拟机3种执行模式
- 解释执行（Interpreted Mode）：不做JIT编译
-  混合模式（MixedMode）：默认。
    -  热点代码被编译执行，其他解释执行。
    -  热点代码的判断依据是调用频率。
- 编译执行（Compiled Mode）：所有函数编译执行

### 参数设置
1. "-Xint"：解释。
2. "-Xmixed"：混合。
3. "-XComp"：编译。
4. "-XX:CompileThreshold"：指定热点代码调用次数阀值。Client模式默认1500，Server模式默认10000。
5. "-XX:+PrintCompilation"：打印即时编译日志。

## 多级编译器
### C1
- 客户端编译器（C1编译器）：Client模式使用的编译器，编译速度快。

### C2
- 服务端编译器（C2编译器）：Server模式使用的编译器，编译优化多，编译后代码质量高，时间长于C1。

### 意义
- 在编译速度和执行效率间取得平衡
#### 0级
- （解释执行）：解释执行，不采集性能监控数据；

#### 1级
-（简单C1编译）：采用C1，最简单的快速编译，根据需要采集性能数据；
#### 2级
- （有限的C1编译）：采用C1，更多的优化编译，可能根据1级采集的性能统计数据，进一步优化编译代码；
#### 3级
-（完全C1编译）：完全使用C1的所有功能，采集性能数据进行优化####  4级
- （C1编译）：完全使用C1的所有功能，完全优化。
#### 参数
- "-XX:+TieredCompilation"开启多级编译。