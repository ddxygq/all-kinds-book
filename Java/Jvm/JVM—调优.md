# 概述
## 基本技能要求
- 掌握JVM常见的参数
- 掌握相关工具
    - 系统自带的工具
    - 第三方工具

## 调优领域
- 响应时间(GC)
- cpu
- io
- 锁竞争

## 总结
- 最快的GC 是不发生GC
- 确定到底是吞吐量优先还是响应时间优先
- 调优是从业务场景开始，没有业务场景的调优都是耍流氓
- 无监控不调优
- 上线前进行压测
### 
-  系统上线前  系统上线后

### 经常发生GC 
#### 数据量太大
- 内存中加载的数据量过于庞大，如一次从数据库取出过多数据；

#### 内存泄漏
- 集合类中有对对象的引用，使用完后未清空，使得不能被JVM回收；(这就是为什么看到很多人在演示内存溢出的时候，平时通过list 来演示的原因)

#### 代码bug
- 代码中存在死循环或循环产生过多重复的对象实体； 

#### 内存分配不当
- 启动参数内存值设定的过小(如果不存在内存泄漏，换句话来说，就是内存中的对象，还是都得存在，那就得修改启动参数，加大内存了，如果已经达到了物理机的限制，那就得升级配置了)

# 调优
- 应该先要调试新生代的内存空间大小
## 选择合适的垃圾回收器

## 新生代的大小
- 新生代太小导致Mionr的频率大幅上升，也会导致大量对象进入旧生代，触发FullGC。
- 新生代太大，导致旧生代太小，FullGC频率上升，也有可能导致MinorGC的时间上升。
- 目标就是让长时间存活的对象尽快进入老年代，避免在年轻代来回复制，
- 内存大小的目标

### CMS 垃圾回收器调优
- 老年代内存越大越好，避免因为浮动垃圾导致的垃圾回收失败

# 案例

## 频繁full-gc和minor gc 
- 由于新生代频繁gc ,导致大量声明周期短的对象进入老年代(survior 不足以容纳)，因为大量新生代对象进入老年代，导致频繁full gc ，调整minor gc 的大小，将一些声明周期比较短的对象留在年轻代。

## 请求高峰期发生full-gc，cms 单次停留时间特别长。

## 老年代空间充裕的情况下发生full-gc
- 由于jdk 版本是1.7 的，发现是方法区的内存空间不足

## 垂直电商，每日最高百万订单，处理订单需要什么样的服务器配置
- 峰值，一小时36万单，每秒钟100单(内存设置100单需要多少内存，取决于)
 - tps qps gps Q
 - 压测






## 例1
- 增大内存后，服务出现间断性的失去响应

## 例2

