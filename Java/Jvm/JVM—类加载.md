[toc]
## 类加载的过程



### 编译

编译其实主要就是将 .java 文件编译成 .class 文件，然后作为虚拟机的输入可执行文件

### 加载

- 是指查找字节流，并且据此创建类的过程。前面提到，对于数组类来说，它并没有对应的字节流，而是由 Java 虚拟机直接生成的。对于其他的类来说，Java 虚拟机则需要借助类加载器来完成查找字节流的过程。

### 链接

- 链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶
#### 验证

- 验证阶段的目的，在于确保被加载类能够**满足 Java 虚拟机的约束条件**。这就好比Tony需要将设计好的房型提交给市政部门审核。只有当审核通过，才能继续下面的建造工作。通常而言，Java 编译器生成的类文件必然满足 Java 虚拟机的约束条件。

##### class 文件格式验证

##### 元数据验证

##### 字节码验证

##### 符号验证

- 字段描述符的全限定名称找到对应的类
- 在类中根据字段描述(方法描述)和简单名称找到字段或者方法
- 根据访问描述符判断是否有访问权限

#### 准备

- 准备阶段的目的，则是为被加载类的**静态字段分配内存**。Java代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。过了这个阶段，咱们算是盖好了毛坯房。
- 这里的初始值，指的是**零值**，而不是具体的变量值。具体的变量值是在初始化的时候在< clinit >() 这个方法里面完成赋值的。
##### 类变量

 - 这里的类变量指的是被static 修饰，而不包括实例变量，实例变量的字段是随着对象分配在堆上的。
##### 常量(类常量)

#### 解析

- 解析的目的就是将常量池中的符号引用替换成直接引用的过程
- 在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至**不知道自己方法、字段的地址**。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。
- 解析阶段的目的，正是将这些**符号引用解析成为实际引用**。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化）
```
Java 虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。
```
#### 引用
##### 符号引用
- 符号引用
##### 直接引用

#### 类或者接口的解析
- 根据全限定名称找类(加载)
- 进行访问权限判定(IllegaAccessError)
#### 字段解析
- 根据字段的全限定名称找类
- 在类中根据字段描述和简单名称找到字段(NoSuchFieldError)
- 判断字段的访问权限(IllegaAccessError)

#### 类方法解析

### 初始化

- 在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。可以看出类变量，一共是经历了两次赋值，**第一次是在准备阶段，为其分配内存的时候，赋予的系统初始值——零值**；第二次是赋予程序开发人员定义的值，也就是程序所需要的值。
- 如果直接赋值的静态字段被final所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被Java编译器标记成常量值（ConstantValue），其初始化直接由Java虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会**被Java编译器置于同一方法中，并把它命名为 < clinit >**。
- 类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。Java 虚拟机会通过加锁来确保类的 < clinit > 方法仅被执行一次。
- 只有当初始化完成之后，类才正式成为可执行的状态。
#### < clinit >

- < clinit >() 方法是编译器自动收集所有的类变量的赋值动作和静态语句块合并生成的
- < clinit >() 方法不同于类的构造函数(init),不需要**显示**的调用父类的构造器，再初始化子类的时候发现父类没有被初始化会自动初始化；但是接口的初始化和类的初始化不一样，不需要初始化父接口，只有当父接口中定义的变量被使用的时候才会初始化。
- < clinit >()  对与类和接口来说，不是必须的，没有静态语句块和没有赋值操作的时候就没有

## 类加载的时机

- 当虚拟机启动时，初始化用户指定的主类；
- 当遇到用以新建目标类实例的new指令时，初始化new指令的目标类；
- 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
- 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
- 子类的初始化会触发父类的初始化；
- 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
- 使用反射 API 对某个类进行反射调用时，初始化这个类；
- 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类
##总结

- JVM并不会直接使用.class文件，类加载链接的目的就是在JVM中创建相应的类结构，会存储在元空间
-  加载阶段是针对单个类的，一般用到的类才会被加载。大部分情况下，不同类的加载阶段是不同的。
-  在加载阶段就该已经写入了方法区，只是被标记为未链接而暂不能使用。



### Class.forName和classloader的区别

Java中Class.forName和classloader都可以用来对类进行加载。

Class.forName除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。

而classloader只将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。

## 类加载器

- 虚拟机中通过一个类的全限定名来捕获类的二进制字节流的代码模块就是类加载器，类加载器开放了自己的加载，让程序可以自行决定类的加载
- 类加载的第一阶段加载，就是由类加载器完成的；任意一个类，都需要由类加载器和类本身一同确定类在虚拟机中的唯一性，对于每一个类加载器都拥有独立的命名空间。
## 类加载器的分类
### 从虚拟机的角度来看

- 从虚拟机的角度来看，只有两种类加载器，一种是启动类加载器，由C++实现，是虚拟机的一部分；另外一种是其他所有的类加载器，由java 语言实现，独立于虚拟机的外部，并且继承自java.lang.ClassLoader

### 从开发人员的角度来看

