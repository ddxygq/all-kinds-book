[toc]

[参考](https://www.jianshu.com/p/20bd2e9b1f03)

[参考](https://mp.weixin.qq.com/s/QXyezti9MzALhI39DlI2Mg)


## 逃逸分析的目的
- **逃逸分析并不是直接的优化手段，而是一个代码分析**，通过动态分析对象的作用域，为其它优化手段如栈上分配、标量替换和同步消除等提供依据，发生逃逸行为的情况有两种：方法逃逸和线程逃逸。
- 逃逸分析的结果，多被用于新建对象操作转换成栈上分配或者标量替换。
- 通过逃逸分析来决定某些实例或者变量是否要在堆中进行分配，如果开启了逃逸分析并且分析到没有逃逸，即可将这些变量直接在栈上进行分配，而非堆上进行分配。

### 逃逸的场景
1. 方法逃逸：当一个对象在方法中定义之后，作为参数传递到其它方法中；
2. 线程逃逸：如类变量或实例变量，可能被其它线程访问到；
> 如果不存在逃逸行为，则可以对该对象进行如下优化：同步消除、标量替换和栈上分配。

### 锁消除
- 即时编译器能够证明对象不逃逸，对该对象的加锁、解锁操作没有意义。因为其他线程对该对象无法操作，因此也不能够对其加锁、解锁。这种情况，即时编译器就可以消除对该不逃逸锁对象的加锁、解锁操作。
- 线程同步本身比较耗，如果确定一个对象不会逃逸出线程，无法被其它线程访问到，那该对象的读写就不会存在竞争，则可以消除对该对象的同步锁，通过-XX:+EliminateLocks可以开启同步消除。


### 栈上分配
- 当逃逸分析能证明新建对象不逃逸，JVM就可以将该对象分配到栈上，在new语句所在的方法退出时，通过弹出当前方法的栈帧来自动回收所分配的内存空间(这样就无须借助垃圾回收器来处理不再被引用的对象)
- 对于线程私有（不可能被其他线程访问）的对象，**将它们打散分配在栈上，而不是在堆上。函数调用结束后自行销毁，无需垃圾回收器介入**。
-  HotSpot 虚拟机并没有采用栈上分配的技术，而是采用了标量替换技术

```
public class EscapeAnalysis {
    private static User user;
    public static void test1() {
        // 逃逸对象
        user = new User();
        user.id = 1;
        user.name = "test1";
    }
    public static void test2() {
        // 非逃逸对象
        User user = new User();
        user.id = 2;
        user.name = "test2";
    }
}

class User {
    int id;
    String name;
}
```

### 标量替换
- 将原本对对象的字段的访问，替换成一个个局部变量的访问。这些字段没有分配实际内存，和栈上分配一样，甚至可以直接存在寄存器中，不需要内存空间。
- 1、标量是指不可分割的量，如java中基本数据类型和reference类型，相对的一个数据可以继续分解，称为聚合量；
- 2、如果把一个对象拆散，将其成员变量恢复到基本类型来访问就叫做标量替换；
- 3、**如果逃逸分析发现一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是在栈上创建若干个成员变量**；通过-XX:+EliminateAllocations可以开启标量替换， -XX:+PrintEliminateAllocations查看标量替换情况。

