[toc]
## 并发的意义
### 并发的优势
#### 资源利用率更好
#### 程序响应更快
### 并发的不足

#### 设计更复杂
- 由于多个线程是共同占有所属进程的资源和地址空间的，那么就会存在多个线程同时访问同一个资源的问题，可能导致线程安全问题。避免多线程编程中线程安全设计较复杂。

#### 上下文切换的开销
- CPU从执行一个线程切换到执行另外一个线程的时候，需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。这种切换称为上下文切换。
- 对于线程的上下文切换实际上就是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。
- 虽然多线程可以使得任务执行的效率得到提升，但是由于在线程切换时同样会带来一定的开销代价，并且多个线程会导致系统资源占用的增加，所以在进行多线程编程时要注意这些因素。

#### 增加资源消耗
- 线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈。它也需要占用操作系统中一些资源来管理线程

## 并发编程面临的三个问题
- 并发编程的本质就是解决三大问题：原子性、可见性、有序性。

### 可见性
- 一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。
- 对于如今的多核处理器，每颗CPU都有自己的缓存，而缓存仅仅对它所在的处理器可见，CPU缓存与内存的数据不容易保证一致。
- 基本上所有的并发模式在解决线程安全问题时，都采用“序列化访问临界资源”的方案，即在同一时刻，只能有一个线程访问临界资源，也称作同步互斥访问。
- 通常来说，是在访问临界资源的代码前面加上一个锁，当访问完临界资源后释放锁，让其他线程继续访问。

### 原子性
> 在并发编程中，原子性的定义不应该和事务中的原子性（一旦代码运行异常可以回滚）一样。应该理解为：一段代码，或者一个变量的操作，**在一个线程没有执行完之前，不能被其他线程执行**。

### 有序性
- 有序性：程序执行的顺序按照代码的先后顺序执行。
- 编译器为了优化性能，有时候会改变程序中语句的先后顺序。例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的Bug。

- 从Java源代码到最终实际执行，要经历三种重排序：编译器优化的重排序、指令级并行的重排序、内存系统的重排序。


#### 重排序遵守数据依赖性
- 数据依赖性：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。

## 其他概念
### 竞态条件
- 当多个线程同时访问同一个资源，其中的一个或者多个线程对这个资源进行了写操作，对资源的访问顺序敏感，就称存在竞态条件。多个线程同时读同一个资源不会产生竞态条件。

### 临界区
- 导致竞态条件发生的代码区称作临界区。在临界区中使用适当的同步就可以避免竞态条件。
```
public class Counter {
    protected long count = 0;
    public void add(long value){
        this.count = this.count + value;
    }
}
```
- 多线程同时执行上面的代码可能会出错：多线程同时执行临界区代码this.count = this.count + value时，同时对同一资源this.count进行写操作，产生了竞态条件。
- 基本上所有的并发模式在解决线程安全问题时，都采用**"序列化访问临界资源"**的方案，即在同一时刻，只能有一个线程访问临界资源，也称作同步互斥访问。通常来说，是在访问临界资源的代码前面加上一个锁，当访问完临界资源后释放锁，让其他线程继续访问。

### 死锁 

## 并发的应用场景
### 充分利用计算机的处理效能
### 并发执行若干任务(一个服务端对多个客户端提供服务)


![image](https://note.youdao.com/yws/res/19097/8D31ED9B5B584531AD97E8A0D08AB9BC)
