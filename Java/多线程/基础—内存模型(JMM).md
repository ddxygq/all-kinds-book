[toc]
# 内存结构与模型

## 缓存一致性的背景
- 计算机中，cpu和内存的交互最为频繁，相比内存，磁盘读写太慢，内存相当于高速的缓冲区。
- 随着cpu的发展，内存的读写速度也远远赶不上cpu。因此cpu厂商在每颗cpu上加上高速缓存，用于缓解这种情况。现在cpu和内存的交互大致如下。
![](https://soaringbirdblog.oss-cn-shanghai.aliyuncs.com/oneblog/20191202220429835.png)

- cpu上加入了高速缓存这样做解决了处理器和内存的矛盾(一快一慢)，但是引来的新的问题 - 缓存一致性
> 如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。
```
CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找，每个cpu有且只有一套自己的缓存。
```
- 因为这些缓存的出现，提高了数据访问性能，避免每次都向内存索取，但是弊端也很明显，不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同——缓存一致性
> 在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致

### 带来的问题
- 原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这**个抽象的底层问题就是提缓存一致性问题**、处理器优化问题和指令重排问题等。
#### 原子性
- 原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行

#### 可见性
- 是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

#### 有序性
- 即程序执行的顺序按照代码的先后顺序执行

## 内存模型
- 多CPU的系统中，每个CPU都有多级缓存，一般分为L1、L2、L3缓存，因为这些缓存的存在，提供了数据的访问性能，也减轻了数据总线上数据传输的压力，同时也带来了很多新的挑战，比如两个CPU同时去操作同一个内存地址
- 解决缓存一致性最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互

### 内存模型的背景
- 为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范
- 。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。
- 它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。

- 内存模型解决并发问题主要采用两种方式：**限制处理器优化和使用内存屏障**。
- 在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等，其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。

### 强内存模型
- 强内存模型，所有CPU在任何时候都能看到内存中任意位置相同的值，这种完全是硬件提供的支持。

### 弱内存模型
- 弱内存模型，需要执行一些特殊指令（就是经常看到或者听到的，memory barriers内存屏障），刷新CPU缓存的数据到内存中，保证这个写操作能够被其它CPU可见，或者将CPU缓存的数据设置为无效状态，保证其它CPU的写操作对本CPU可见。
- 通常这些内存屏障的行为由底层实现，对于上层语言的程序员来说是透明的（不需要太关心具体的内存屏障如何实现）。

### 内存屏障
#### 为什么需要内存屏障
- 由于现代操作系统都是多处理器操作系统，每个处理器都会有自己的缓存，可能存再不同处理器缓存不一致的问题，而且由于操作系统可能存在重排序，导致读取到错误的数据，因此，操作系统提供了一些内存屏障以解决这种问题.

#### jvm 的内存屏障
- 用volatile可以解决上面的问题，不同硬件对内存屏障的实现方式不一样。java屏蔽掉这些差异，通过jvm生成内存屏障的指令。
- 对于读屏障:在指令前插入读屏障，可以让高速缓存中的数据失效，强制从主内存取。
- 当我们声明某个变量为volatile修饰时，这个变量就有了线程可见性，volatile通过在读写操作前后添加内存屏障。
```
//相当于读写时加锁，保证及时可见性，并发时不被随意修改。
public class SynchronizedInteger {
  private long value;

  public synchronized int get() {
    return value;
  }

  public synchronized void set(long value) {
    this.value = value;
  }
}
```
#### 内存屏障的作用
- 阻止屏障两侧指令重排序
- 强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。


## Java 内存模型
- 区分一个概念 Java虚拟机的内存结构，JVM中的堆啊、栈啊、方法区什么的，是Java虚拟机的内存结构，Java程序启动后，会初始化这些内存的数据
- Java内存模型中，描述了在多线程代码中，哪些行为是正确的、合法的，以及多线程之间如何进行通信，代码中变量的读写行为如何反应到内存、CPU缓存的底层细节也就是虚拟机将变量存储到内存和从内存中取出的细节
- 在Java中包含了几个关键字：volatile、final和synchronized，帮助程序员把代码中的并发需求描述给编译器。Java内存模型中定义了它们的行为，确保正确同步的Java代码在所有的处理器架构上都能正确执行。

```
简要言之，jmm是jvm的一种规范，定义了jvm的内存模型。它屏蔽了各种硬件和操作系统的访问差异，
不像c那样直接访问硬件内存，相对安全很多
它的主要目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。
可以保证并发编程场景中的原子性、可见性和有序性。
```

### 主内存和工作内存
- java 内存模型基本如下
![](https://soaringbirdblog.oss-cn-shanghai.aliyuncs.com/oneblog/20191202220440140.png)
- 我们可以对比这来看java 的内存模型和物理机的处理器与内存交互，其实还是有很多相识之处，java 的内存模型规定了所有的变量都要存储在主内存里，每条线程还有自己的工作内存，类比前面的高速缓存，线程的工作内存里面的变量实际上是主内存里面变量(类变量、实例变量但不包括局部变量和方法的入参)的拷贝，而且虚拟机还规定了对变量的所有操作都需要在工作内存中进行，而**不能直接读写主内存**。不能线程的工作内存也不能共享(主内存是共享的)，也就是说不能访问其他线程工作内存里的变量，不同线程之间变量的交换必须通过主内存完成。

### 内存间交互操作(一致性协议的实现)
#### lock
- 锁定，作用于工作内存，将一个变量标识为被一个线程独占

#### unlock
- 解锁，作用于主内存，把一个处于锁定状态的变量释放出来，释放之后才能被其他线程锁定。

#### read
- 从主内存中读取到工作内存，供load 使用

#### load
- 将read 进来的值放到工作内存中的变量副本中去

#### use
- 使用load 进来的变量的值，每当虚拟机遇到要使用变量值得字节码指令的时候，就会执行这个操作

#### assign
- 赋值操作

#### store
- 存储，将工作内存中变量的值传送到主内存中，供write 使用

#### write
- 写入，将工作内存中传输过来的值，写入主内存中的变量。

### 内存间交互操作的规定
>read 和load，store和write必须成对出现，且顺序如当前所示，但是不需要连续执行比如read和load之间可以插入其他的指令。
>
>不允许一个线程丢弃它最近的assign的操作，最近是指最后一次的赋值，赋值之后的改变必须同步回主内存。
>
>不允许一个线程无原因地（没有发生过任何assign操作的）把数据从线程的工作内存同步回主内存。
>
>一个新的变量只能在主内存中诞生，对一个变量使用store和use之前必须先使用load和assign
>
>一个变量只能在同一时刻被一个线程锁定，但是lock操作可以被同一个线程重复执行多次，但是对应的unlock也需要执行相同次数
>
>对变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新执行load或assign操作初始化变量的值。
>
>未被lock的变量不允许unlock
>
>对一个变量执行unlock操作之前，必须把此变量同步回主内存中（执行store和write操作）

### 先行发生原则
#### 原则的意义
- 理论上,jMM内存操作(协议)和内存交互的操作原则和对volatile操作的一些规定就已经决定了Java 程序哪些操作在并发环境下是安全的了；但是上面的定义太繁琐有不便记忆，所以先行发生原则可以看做是等效的
#### 原则的主要内容
>1、程序次序规则。在一个线程内，书写在前面的代码先行发生于后面的。确切地说应该是，按照程序的控制流顺序，因为存在一些分支结构。
>
>2、Volatile变量规则。对一个volatile修饰的变量，对他的写操作先行发生于读操作。
>
>3、线程启动规则。Thread对象的start()方法先行发生于此线程的每一个动作。
>
>4、线程终止规则。线程的所有操作都先行发生于对此线程的终止检测。
>
>5、线程中断规则。对线程interrupt()方法的调用先行发生于被中断线程的代码所检测到的中断事件。
>
>6、对象终止规则。一个对象的初始化完成（构造函数之行结束）先行发生于发的finilize()方法的开始。
>
>7、传递性。A先行发生B，B先行发生C，那么，A先行发生C。
>
>8、管程锁定规则。一个unlock操作先行发生于后面对同一个锁的lock操作。


# 线程概论
- 并发不一定要依赖多线程，例如php 中的并发是多进程并发
- 线程是比进程更轻量级的调度单位，线程的引入可以把进程的资源分配和执行调度——多个线程可以共享进程资源，又可以独立调度(进程是操作系统进行资源分配的基本单位，线程是cpu进行调度的基本单位)

## 线程的理论实现方式
### 内核线程(Kernal-Level Thread,KTL)
### 轻量级进程(LWP light weight process)
### 用户线程
### 用户线程+轻量级进程实现

## java 线程的实现方式
### 继承Thread类
### 实现Runnable接口
### lambda方式创建线程任务
### 使用内部类的方式
### 定时器
### 带返回值的线程实现方式
### 基于线程池的方式

## 线程安全到底是在讲什么
- 多个线程访问一个对象的时候，不用考虑哲学线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，调优这个对象的行为都能获得正确的结果，那么这个对象是线程安全的


## 指令重排
- 重排序可以发生在好几个地方：编译器、运行时、JIT等，比如编译器会觉得把一个变量的写操作放在最后会更有效率，编译后，这个指令就在最后了（前提是只要不改变程序的语义，编译器、执行器就可以这样自由的随意优化），一旦编译器对某个变量的写操作进行优化（放到最后），那么在执行之前，另一个线程将不会看到这个执行结果。
- 通过内存屏障的功能，我们可以禁止一些不必要、或者会带来负面影响的重排序优化，在内存模型的范围内，实现更高的性能，同时保证程序的正确性。
- jvm 的指令重排优化对应的是处理器的乱序执行





# java 中常见的两个关键字

## volatile
- Volatile字段主要用于线程之间进行通信，volatile字段的每次读行为都能看到其它线程最后一次对该字段的写行为，通过它就可以避免拿到缓存中陈旧数据。它们必须保证在被写入之后，会被刷新到主内存中，这样就可以立即对其它线程可以见。
- 在读取volatile字段之前，缓存必须是无效的，以保证每次拿到的都是主内存的值，都是最新的值。volatile的内存语义和sychronize获取和释放monitor的实现目的是差不多的
- 声明某个变量为volatile修饰时，这个变量就有了线程可见性，volatile通过在读写操作前后添加内存屏障。
- volatile 是java x虚拟机提供的最轻量级的线程同步机制——保证了volatile变量在各个线程中是一致的，但是不能保证volatile变量的运算在多线程的环境下是安全的，一致的仅仅保证了变量的可见性，但是基于可见性变量的运算不能保证整个运算时原子性的

### 特性
- 可见性，对于一个该变量的读，一定能看到读之前最后的写入。
- 原子性，对volatile变量的读写具有原子性，即单纯读和写的操作，都不会受到干扰。
- 阻止指令重排

### volatile 的适用场景
- 因为不能保证运算的原子性，所以我们就不能单独借助volatile 来完成线程安全的变量运算
- 但是我们可以借助volatile 的可见性，在多线程的环境下完成 true 或 false 的判断，例如发生运算的条件、配置的更新

## synchronized 
- Synchronization有多种语义，其中最容易理解的是互斥，对于一个monitor对象，只能够被一个线程持有，意味着一旦有线程进入了同步代码块，那么其它线程就不能进入直到第一个进入的线程退出代码块（这因为都能理解）。
- 使用synchronization并非单单互斥功能，Synchronization保证了线程在同步块之前或者期间写入动作，对于后续进入该代码块的线程是可见的（又是可见性，不过这里需要注意是对同一个monitor对象而言）。在一个线程退出同步块时，线程释放monitor对象，它的作用是把CPU缓存数据（本地缓存数据）刷新到主内存中，从而实现该线程的行为可以被其它线程看到。在其它线程进入到该代码块时，需要获得monitor对象，它在作用是使CPU缓存失效，从而使变量从主内存中重新加载，然后就可以看到之前线程对该变量的修改。
- 但从缓存的角度看，似乎这个问题只会影响多处理器的机器，对于单核来说没什么问题，但是别忘了，它还有一个语义是禁止指令的重排序，对于编译器来说，同步块中的代码不会移动到获取和释放monitor外面。

## 关键字对三性的影响
### 原子性
#### synchronized

- final 修饰的字段一旦完成初始化，不会将this 传递出去(this 逃逸)，那么其他线程能看到的都是一样的——外部课件的状态永远不会改变，所以不可变才是最简单、最纯粹的安全。

### 可见性
#### synchronized
#### volatile

#### final
### 有序性
- synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：**volatile关键字会禁止指令重排，synchronized关键字保证同一时刻只允许一条线程操作**。


![image-20201126155147175](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/26/15:51:47-image-20201126155147175.png)

## cas
- 适用于竞争不激烈、多核cpu 的情况下(线程不会阻塞，还会占用当前cpu`)

## 线程安全的实现方法
### 互斥同步
- 同步指的是在多线程并发访问共享数据的时，保证共享数据在同一时刻，只能被一个(或者一些,使用信号量的时候)线程使用
- 互斥是实现同步的手段，互斥是因，同步是果；互斥是方法，同步是目的

#### 互斥同步的实现
##### 临界区
##### 互斥量
##### 信号量