[toc]
## 其他
- 模板模式应用场景：在一个项目的规则引擎中，一个规则引擎有一系列规则过滤，这个过滤步骤基本上是确定的，只是某些步骤在不同的场景下需要相互替换，模板方法定义了方法调用顺序，需要用到一个钩子，让子类去实现这个方法。
模板模式解决问题：解决了以后可拓展的问题，如果以后需要在新场景下新增规则方法，只需新增一个类，实现钩子方法即可，不需改动既有代码。
2.2）单例模式应用场景：用于加载项目中需要的配置文件的资源类。
单例模式解决问题：解决了资源共用，避免创建出大量资源对象，节省了JVM内存资源

- 门面设计模式，对外提供统一的接口，例如在springcloud中提供统一的feinclient接口，所有外部系统都通过feinclient接口进行接入，从而不关心内部接口的调用实现。 sl4j


- 创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。
- 单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。
- JDBC 驱动是桥接模式的经典应用。
- 通过剖析 Java IO 类的设计思想，再学习一种新的结构型模式，装饰器模式。
-

- 符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理模式、桥接模式，还有现在的装饰器模式
- 代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类
- 
- 代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，**主要目的是控制访问，而非加强功能**，这是它跟装饰器模式最大的不同。
- 桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。
- 装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。
- 适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口
- 桥接模式的目标是:分离.适配器的目标是:合并.
- 多次讲过，设计原则、思想、模式很多都是相通的，是同一个道理不同角度的表述
- 适配器是做接口转换，解决的是原接口和目标接口不匹配的问题。门面模式做接口整合，解决的是多接口调用带来的问题。

- 享元模式在 Java Integer、String 中的应用
- 创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合或组装”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题
- 设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。
- 借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚松耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性
- 模板模式主要是用来解决复用和扩展两个问题
- "设计原则和思想比设计模式更加普适和重要"，被这句话一下子点醒了。可以这样说，设计原则和思想是更高层次的理论和指导原则，设计模式只是这些理论和指导原则下，根据经验和场景，总结出来的编程范式。
- 模板模式、策略模式，今天，我们来学习职责链模式。这三种模式具有相同的作用：复用和扩展，在实际的项目开发中比较常用，特别是框架开发中，我们可以利用它们来提供框架的扩展点，能够让框架的使用者在不修改框架源码的情况下，基于扩展点定制化框架的功能
- 设计模式应该从解决问题的场景来看，不应该从代码结构来看。语法规则就那么几个，代码结构类似或者相同是大概率的。只有知道解决了什么问题，才能写出好的代码。本质上来说，它跟大部分设计模式一样，都是为了解耦代码，应对代码的复杂性，让代码满足开闭原则，提高代码的可扩展性
- 状态模式并不是很常用，但是在能够用到的场景里，它可以发挥很大的作用。从这一点上来看，它有点像我们之前讲到的组合模式
- 迭代器模式主要作用是解耦容器代码和遍历代码
- 在今后的一个月内，写代码前、中、后，都思考一下代码的扩展性、可读性、可维护性、可测试性等代码质量问题，看看自己编写的代码是否符合这些质量要求，有没有需要继续优化重构的地方
- 
- 比较典型的抽象类的使用场景（模板设计模式），Logger 是一个记录日志的抽象类
- 工厂模式 Java 中的 Calendar、DateFormat 类。DI 框架
- 消息队列，作为观察者模式的的代表，极大程度地实现了解耦，也在很大程度上解决了资源有限时的高并发崩溃。
- 
## 创建型设计模式
- 创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。
- 单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。

## 结构性设计模式
- 结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题
