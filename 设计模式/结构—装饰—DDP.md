[toc]
## 装饰器模式
- 装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承
- 它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据
- 装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口(这个应该是和代理的区别了)

### 例子
#### java io 流

### 对比组合
- 第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类
```
InputStream in = new FileInputStream("/user/wangzheng/test.txt");
InputStream bin = new BufferedInputStream(in);
DataInputStream din = new DataInputStream(bin);
int data = din.readInt();
```
- 第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点

### 对比代理模式
#### 相同点
- 代理模式和装饰者模式都是 代码增强这一件事的落地方案。

#### 不同点
```
你是一个优秀的歌手，只会唱歌这一件事，不擅长找演唱机会，谈价钱，搭台，这些事情你可以找一个经纪人帮你搞定，经纪人帮你做好这些事情你就可以安稳的唱歌了，让经纪人做你不关心的事情这叫代理模式。
你老爱记错歌词，歌迷和媒体经常吐槽你没有认真对待演唱会，于是你想了一个办法，买个高端耳机，边唱边提醒你歌词，让你摆脱了忘歌词的诟病，高端耳机让你唱歌能力增强，提高了基础能力这叫装饰者模式。
```
- 前者实际上是由框架处理的，也就是把缓存的事情代理给框架去处理了；而后者则还是由应用自己处理，应用调用方得到的是一个增强过的类。
- 前者个人认为偏重业务无关，高度抽象，和稳定性较高的场景（性能其实可以抛开不谈）。后者偏重业务相关，定制化诉求高，改动较频繁的场景。
- Proxy关注对象的信息隐藏及访问控制,Decorator关注为对象动态的添加功能, Decorator体现多态性, Proxy体现封装性.
- 装饰器模式可以认为是对代理模式的拓展、延伸。代理模式是1对1，装饰器模式是1对多


#### 缓存的例子
- 对于添加缓存这个应用场景使用哪种模式，要看设计者的意图，如果设计者**不需要用户关注是否使用缓存功能，要隐藏实现细节，也就是说用户只能看到和使用代理类**，那么就使用proxy模式
- 反之，如果设计者**需要用户自己决定是否使用缓存的功能**，需要用户自己新建原始对象并动态添加缓存功能，那么就使用decorator模式
```
// 代理模式的代码结构(下面的接口也可以替换成抽象类)
public interface IA {
  void f();
}
public class A impelements IA {
  public void f() { //... }
}
public class AProxy impements IA {
  private IA a;
  public AProxy(IA a) {
    this.a = a;
  }
  
  public void f() {
    // 新添加的代理逻辑
    a.f();
    // 新添加的代理逻辑
  }
}

// 装饰器模式的代码结构(下面的接口也可以替换成抽象类)
public interface IA {
  void f();
}
public class A impelements IA {
  public void f() { //... }
}
public class ADecorator impements IA {
  private IA a;
  public ADecorator(IA a) {
    this.a = a;
  }
  
  public void f() {
    // 功能增强代码
    a.f();
    // 功能增强代码
  }
}
```
- 其实就是代理模式的增强可能和原始功能无关，也有可能是用到了原始功能在此基础上增加了性能"副作用"
- 装饰器模式就是是单纯的对