## API 使用优化
- 批量命令的使用  mset
- pipline 使用
- rename 尽量换成 renamenx 防止覆盖点有用的键
- rename 和 del 使用的时候要小心，如果键对应的值很大可能造成redis 阻塞
- 对于字符串类型，**set 会去掉过期时间(这个经常被忽略)**
- 使用setex 代替 set+expire 不但是原子执行还会减少网络时间
- 线上服务 keys * 命令不能使用，应该使用scan，对应集合hgetall,smembers,zrange  的命令不能使用，应该使用对应的scan
> scan 可以结局keys 命令可能阻塞的问题，但是引入新的问题是遍历可能不完整(新增的键)

## client 优化
- client 端存在大量可优化的地方


## 其他
1. 查看内存使用情况，看是否有大量内存碎片
2. 禁用部分慢查询操作，尽量使用高效的操作（批量，pipline）
3. 查看持久化配置是否合理（最近一次fork的时长）
		a. 控制每个redis 实例的大小，fork 的时长和内存大小成正比
4. 慢查询的监控
		a. 合理使用API
		b. 拆分大对象
5. 避免去量复制
		a. 重启时的全量复制
		b. 复制缓冲区太小的去量复制
6. 拓扑结构
		a. 针对读写情况来选择合适的结构
		b. 树形结构来避免复制风暴
7. 阻塞问题
		a. 命令阻塞
		b. 慢查询阻塞
		c. Cpu 饱和阻塞(调整了压缩数据结构的大小)
		d. Fork 阻塞（info status）
		e. AOF 阻塞(info persistence)
		f. 内存交换阻塞
		g. Cpu 竞争阻塞（将redis 和其他 cpu密集型任务部署到了一起）
		h. 网络问题
8. 对象优化
		a. 序列化策略
		b. 缩减键值对象
		c. 尽量使用整数
9. 数据结构优化
### string 
- 尽量不要使用append 和 setrange 直接使用set 命令——减低预分配带来的内存浪费和碎片化
### 字符串重构
对于json 这样的字符串我们可以使用 hash 存储，这样就可以部分修改，而不应整存整取（注意修改ziplist 的阈值）