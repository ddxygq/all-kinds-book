
[toc]

## 缓存
### 换粗的意义
1. 加速读写
2. 降低后端的负载

### 引发的问题
1. 数据一致性
2. 代码维护成本（需要处理缓存层的逻辑）
3. 运维成本（redis 的运维）

### 本地缓存和分布式缓存
- 缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存
- 最主要的特点是轻量以及快速，生命周期随着 jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，**缓存不具有一致性**。
- 使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。

## 缓存常见的问题
### 缓存雪崩
- 	由于某些原因缓存层失效，不能提供服务，此时所有请求都会到达存储层
- 们可以简单的理解为：由于原有缓存失效，新缓存未到期间,导致这个的原因 1. 大面积缓存失效 2. 缓存宕机

> 例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。

#### 解决方案
- 保证缓存层高可用
- 大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证**不会有大量的线程对数据库一次性进行读写**，从而避免失效时大量的并发请求落到底层存储系统上。
- 还有一个简单方案就时讲缓存失效时间分散开
- 依赖隔离组件——服务降级
> 对于个性化推荐系统，当推荐系统不可用的时候，可以补充点热点数据，不至于造成前端页面开天窗


### 缓存穿透
- 缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。
- 这样请求就**绕过缓存直接查数据库**，这也是经常提的缓存命中率问题。

#### 原因
##### 自身业务代码出现问题
##### 恶意攻击

#### 解决办法
- 最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
- 另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。

##### 存储层不命中之后，仍让将空对象缓存
- 做空值缓存，一旦是攻击，就会导致内存浪费（需要设置过期时间）
- 空值缓存，不是攻击，就会导致数据不一致（存储层添加了这样的数据）

##### 布隆过滤器（将存在的key用布隆过滤器提前保存起来）

- 布隆过滤器（将存在的key用布隆过滤器提前保存起来）做第一层拦截 例如推荐系统
- 适用场景 数据命中不高，数据相对稳定，实时性低

### 缓存击穿
- 指一个key非常热点，大并发集中对这个key进行访问，**当这个key在失效的瞬间，仍然持续的大并发访问就穿破缓存，转而直接请求数据库**。
 "缓存+过期时间"的策略可以加速度读写，又可以保证数据的定期更新——存在的问题（1.是一个热点key,也就是访问量非常大，并且重建依赖短时间内不能完成），在缓存失效期间，大量访问抵达存储层，并且多个访问，每一个都没有获取到数据的时候，都会重建这个复杂的key
1. 解决方案
	a. 互斥锁——只允许一个线程进行重建
	b. 永远不过期（手动去更新）

#### 解决方案
- 在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来**锁住当前key的访问**，访问结束再删除该短期key。

### 缓存预热
- 缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。
- 这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

#### 解决思路
- 直接写个缓存刷新页面，上线时手工操作下；
- 数据量不大，可以在项目启动的时候自动进行加载；
- 定时刷新缓存；

### 缓存更新

1. LRU、LFU、FIFO 等算法（需要设置最大内存使用量）
2. 超时剔除（expire 命令）
3. 主动更新（应对一致性要求高的，可以利用消息系统来通知缓存系统进行更新）
推荐

#### 低一致性业务
低一致性业务——最大内存和淘汰策略

#### 高一致性业务

高一致性业务——超时剔除+主动更新（主动更新结束后重置超时剔除）


### 缓存降级
- 当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。
- 缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。