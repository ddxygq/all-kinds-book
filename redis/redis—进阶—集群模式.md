[toc]
# redis 集群模式 
- 主从解决了压力的问题——存在高可用的问题
- sentinel模式解决了高可用的问题——存在内存限制
- cluster模式 解决了上面的问题
> Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。

## 主从模式
```
需要注意的是主从和主备之间的区别
```
1. 主从模式的一个作用是备份数据，这样当一个节点损坏（指不可恢复的硬件损坏）时，数据因为有备份，可以方便恢复。
2. 另一个作用是负载均衡，所有客户端都访问一个节点肯定会影响Redis工作效率，有了主从以后，查询操作就可以通过查询从节点来完成。
3. 对于读压力特别大的时候，可以一主多从

### 不足
- master节点挂了以后，redis就不能对外提供写服务了，因为剩下的slave不能成为master这个缺点影响是很大的，尤其是对生产环境来说，是一刻都不能停止服务的，所以一般的生产坏境是不会单单只有主从模式的。
- 受制于单机内存的大小
- 客户端在 Redis 的主节点修改了数据后异步通知丛节点，立即返回，即使在主从网络断开的情况下，主节点依旧可以正常对外提供修改服务， **Redis 满足「可用性」但削弱了一致性（A P）**,也可以用wait指令同步执行

### 实现原理 replication ID，offset
- 复制ID代表数据集的版本;  offset表示master发送给slaves复制流的偏移量，即slaves复制到哪里了.

## sentinel模式
- sentinel的中文含义是哨兵、守卫。也就是说既然主从模式中，当master节点挂了以后，slave节点不能主动选举一个master节点出来，那么我就安排一个或多个sentinel来做这件事，当sentinel发现master节点挂了以后，sentinel就会从slave中重新选举一个master。

### sentinel模式的理解
- sentinel模式是建立在主从模式的基础上，如果只有一个Redis节点，sentinel就没有任何意义
- 当master节点挂了以后，sentinel会在slave中选择一个做为master，并修改它们的配置文件，其他slave的配置文件也会被修改，比如slaveof属性会指向新的master
- sentinel因为也是一个进程有挂掉的可能，所以sentinel也会启动多个形成一个sentinel集群
- 一个sentinel或sentinel集群可以**管理多个主从Redis**。
- sentinel最好不要和Redis部署在同一台机器，不然Redis的服务器挂了以后，sentinel也挂了
- 当使用sentinel模式的时候，**客户端就不要直接连接Redis，而是连接sentinel的ip和port**，由sentinel来提供具体的可提供服务的Redis实现，这样当master节点挂掉以后，sentinel就会感知并将新的master节点提供给使用者。

### 主要职责
#### 集群监控
- 负责监控 redis master 和 slave 进程是否正常工作。
#### 消息通知
- 如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
#### 故障转移
- 如果 master node 挂掉了，会自动转移到 slave node 上。
#### 配置中心
- 如果故障转移发生了，通知 client 客户端新的 master 地址。 
### 故障转移
- 所有的sentinel都向一个master的channel订阅，所有的sentinel可以获取对方哨兵的信息保存下来。这样所有的sentinel节点两两进行连接。
- 当master出现故障了，一个sentinel发现master，把当前master置为主观不可用，继续等待其他sentinel节点确认。当确认节点>=配置值。那么master是真的挂掉了， 进入failover流程。

#### failover

- 所有的节点发起failover，但是最后只有一个sentinel节点作为发起者。这个时候就要开始选举。

- 每一个确认了master客观不可用的节点向周围广播自己参加选举。
- 每一个接受参选的sentinel节点如果没人向它发送参数请求，它就会发送自己作为选举节点广播出去。反之则拒绝其他节点参数并把之前的节点回复给sentinel。
- 每一个sentinel如果获得了超过半数的票数，那么确认该sentinel为leader。接下来就是这个leader从所有的slave中选取一个作为新的master

#### 如何选择slave 
- 与master断开连接的时间 
- Slave的优先级
- Processed replication id and offset RunID 

### 不足
- sentinel模式基本可以**满足一般生产的需求，具备高可用性**。但是当数据量过大到一台服务器存放不下的情况时，主从模式或sentinel模式就不能满足需求了，这个时候需要对存储的数据进行分片，将数据存储到多个Redis实例中

## cluster模式
- cluster的出现是为了解决单机Redis容量有限的问题，将Redis的数据根据一定的规则分配到多台机器
- 因为Redis的数据是根据一定规则分配到cluster的不同机器的，当数据量过大时，可以新增机器进行扩容这种模式适合数据量巨大的缓存要求，当数据量不是很大使用sentinel即可。
- Redis 集群通过分区（partition）来提供一定程度的可用性（availability）即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求(需要注意的是集群中节点也是存在单点问题的，所以需要分片备份)

### 特点
- 去中心化的，每个节点负责整个集群的一部分数据；
- 每个节点负责的数据多少可能不一样。节点相互连接组成一个对等的集群；
- 它们之间通过一种特殊的二进制协议相互交互集群信息；Redis Cluster 的客户端可以直接定位到目标节点；

### Redis集群的主从架构
- 为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品。
```
例如有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少B节点所承担的哈希槽这个范围的槽而不可用。
然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了
当然如果B和B1都down了，那集群还是不可用的，不过这种情况微乎其妙，基本不用考虑，出发你交换机挂了吧，或者机房断电。
```
### 集群数据共享算法

#### 哈希槽算法
- Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现
- Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。
- 集群中的每个节点负责处理一部分哈希槽
```
节点 A 负责处理 0 号至 5500 号哈希槽。
节点 B 负责处理 5501 号至 11000 号哈希槽。
节点 C 负责处理 11001 号至 16384 号哈希槽。
```
- 将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点
```
如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。
与此类似， 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。
```
#### 余数哈希算法
- 通过客户端实现路由算法，来将某个key路由到某个具体的节点，一致性hash算法也就是取模的方法，对服务器的数量进行 取模，一致性hash算法
- 所有的缓存数据是分散存放在各个Redis节点上的，通过客户端实现路由算法，来将某个key路由到某个具体的节点。
- 这个路由算法是分布式缓存伸缩性能否成功的关键。
它的职责不仅仅是由key算出一个Redis的地址，而且必须**让新上线的缓存服务器对整个分布式缓存集群影响最小**，使得扩容后，整个缓存服务器集群中已经缓存的数据尽可能还被访问到
```
比如用取余数(hash(key)%serverNum)做为该算法，Redis需要由3个节点，扩大到4个节点，会有75%的key无法命中
当服务器数量为100台时，再增加一台新服务器，不能命中率将达到99%，这和整个缓存服务挂了一个效果。
```
- 使用余数Hash的路由算法，在扩容的时候会造成大量的数据无法正确命中（其实不仅仅是无法命中，那些大量的无法命中的数据还在原缓存中在被移除前占据着内存）
##### 存在的问题
- 扩容导致大量数据无法命中
- 无法命中的数据还在原缓存中在被移除前占据着内存

#### 一致性Hash算法
- 一致性Hash算法通过一个叫做一致性Hash环的数据结构实现Key到缓存服务器的Hash映射
- 一致性哈希算法在1997年由麻省理工学院的Karger等人在解决分布式Cache中提出的，设计目标是为了解决因特网中的热点(Hot spot)问题
##### 算法原理
1. 首先求出memcached服务器（节点）的哈希值，并将其配置到0～23^2的圆（continuum）上
2. 然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。
2. 然后从数据映射到的位置**开始顺时针查找**，将数据保存到找到的第一个服务器上。如果超过2^32仍然找不到服务器，就会保存到第一台memcached服务器上。。
- 三个Node点分别位于Hash环上的三个位置，然后Key值根据其HashCode，在Hash环上有一个固定位置，位置固定下之后，Key就会顺时针去寻找离它最近的一个Node
![image](https://note.youdao.com/yws/res/50586/954C38A9A23A40C4B921352B33A2D9F4)
##### 添加节点
- 余数分布式算法由于保存键的服务器会发生巨大变化而影响缓存的命中率
- 但Consistent Hashing中，只有在圆（continuum）上增加服务器的地点**逆时针方向的第一台服务器上的键会受到影响**

#### 基于客户端分配
![image-20201125213256966](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:32:57-image-20201125213256966.png)
- Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。
- 其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。
- Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool

##### 优点

优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强

##### 缺点

由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。
客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化

#### 基于代理服务器分片

![image-20201125213315197](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:33:15-image-20201125213315197.png)
- 客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端

##### 特点
- 透明接入，业务程序不用关心后端Redis实例，切换成本低
- Proxy 的逻辑和存储的逻辑是隔离的
- 代理层多了一次转发，性能有所损耗
##### 业界开源方案
- Twtter开源的Twemproxy
- 豌豆荚开源的Codis

#### 共享算法需要考虑的问题
##### 平衡性(Balance)
- 平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。
##### 单调性(Monotonicity)
- 单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。
- 简单的哈希算法往往不能满足单调性的要求，如最简单的线性哈希：x = (ax + b) mod (P)，在上式中，P表示全部缓冲的大小。不难看出，当缓冲大小发生变化时(从P1到P2)，原来所有的哈希结果均会发生变化，从而不满足单调性的要求。

##### 平滑性(Smoothness)
- 平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。

### 集群的一致性保证
- Redis 集群不保证数据的强一致性（strong consistency）,使用异步复制（asynchronous replication）是 Redis 集群可能会丢失写命令的其中一个原因
```
客户端向主节点 B 发送一条写命令。
主节点 B 执行写命令，并向客户端返回命令回复。
主节点 B 将刚刚执行的写命令复制给它的从节点 B1 、 B2 和 B3 。
```
- 主节点对命令的复制工作发生在返回命令回复之后，因为如果每次处理命令请求都需要等待复制操作完成的话，那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。

### 跳转
当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据。

## 数据一致性
### 同步原理
1. 当一个从数据库启动时，会向主数据库发送sync命令，
2. 主数据库接收到sync命令后会开始在后台保存快照（执行rdb操作），并将保存期间接收到的命令缓存起来
3. 当快照完成后，redis会将快照文件和所有缓存的命令发送给从数据库。
4. 从数据库收到后，会载入快照文件并执行收到的缓存的命令。

#### master
- 首先slave发出指令sync。master被动把当前的slave节点加入集群(发送(replication ID,offset)给master )
- master收到了sync指令以后，启用bgsave操作。
- bgsave操作完成以后，master把快照发给slave。
- 在快照发送期间，所有发给master的新指令都会存放到backlog队列里面，接下来继续发送给slave。
- backlog发送完成以后，接下来master获取的写操作也会异步发给slave。

#### slave
- 发送sync指令以后继续提供服务。
- 开始接受master的数据，在这之前会把所有的slave内存数据清空，同时写入内存
- 接受backlog的数据并且执行。
- 之后一直接受master的数据，保持一致。

#### 初次全量同步
![image-20201125213345739](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:33:46-image-20201125213345739.png)

- master fork subprocess ，生成RDB文件。同时，将接收到的所有新的写入命令都放入缓冲 区(replicaton buffer)中。 copy-on-write 
- rdb文件生成完成后，master将文件传输给slave，slave将它保存到磁盘上，然后加载 到内存中。 
- 然后，master将所有缓存的命令都发送给slave。
- 以上完成全量复制同步，之后master每执行一个写命令，都会发送给slave。

#### 命令传播
- slave已经同步过master了，那么如果后续master进行了写操作，比如说一个简单的set name redis，那么master执行过当前命令后，会将当前命令发送给slave执行一遍，达成数据一致性。

### 重新复制
- 当slave断开重连之后会进行重新同步，**重新同步分完全同步和部分同步**
> 出现网络抖动，那么master有需要全量推数据给slave了。很消耗性能。因此有了一个优化操作，断点续传， slave和master使用psync指令，同时维护一个offset。当出现抖动断开了以后，slave重连到master，会把offset发给master。master会把大于offset的数据发送给slave。

#### 服务器运行ID
1. 每个redis服务器开启后会生成运行ID。
2. 当进行初次同步时，master会将自己的ID告诉slave，slave会记录下来，当slave断线重连后，发现ID是这个master的就会尝试进行部分重同步。当ID与现在连接的master不一样时会进行完整重同步。

#### 复制偏移量
- 复制偏移量包括master复制偏移量和slave复制偏移量，当初次同步过后两个数据库的复制偏移量相同，
- 之后master执行一次写命令，那么master的偏移量+1，master将写命令给slave，slave执行一次，slave偏移量+1，这样版本就能一致。

#### 复制积压缓冲区
- 复制积压缓冲区是由master维护的固定长度的先进先出的队列。
- 当slave发送psync，会将自己的偏移量也发送给master，当slave的偏移量之后的数据在缓冲区还存在，就会返回+continue通知slave进行部分重同步。
- 当slave的偏移量之后的数据不在缓冲区了，就会进行完整重同步。


## 扩展
- 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1<- Slave2 <- Slave3…这样的结构方便解决单点故障问题，实现 Slave 对 Master的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。
- Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务
- 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一
- 为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网
- 尽量避免在压力很大的主库上增加从