[toc]
## SDS
```
struct sdshdr {
    int len;
    int free;
    char buf[];
};
```
- Redis没有直接使用C字符串(即以空字符’\0’结尾的字符数组)作为默认的字符串表示，而是使用了SDS。SDS是简单动态字符串(Simple Dynamic String)的缩写。

- 其中，buf表示字节数组，用来存储字符串；len表示buf已使用的长度，free表示buf未使用的长度

![image-20201125213800928](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:38:01-image-20201125213800928.png)

- 通过SDS的结构可以看出，buf数组的长度=free+len+1（其中1表示字符串结尾的空字符）；所以，一个SDS结构占据的空间为：free所占长度+len所占长度+buf数组的长度=4+4+free+len+1=free+len+9。

## DicEntry

![image-20201125213822302](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:38:22-image-20201125213822302.png)

- set hello world

![image-20201125213837531](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:38:38-image-20201125213837531.png)
- Redis是Key-Value数据库，因此对每个键值对都会有一个dictEntry，里面存储了指向Key和Value的指针；next指向下一个dictEntry，与本Key-Value无关。
- Key（"hello"）并不是直接以字符串存储，而是存储在SDS结构中
- Value("world")既不是直接以字符串存储，也不是像Key一样直接存储在SDS中，而是存储在redisObject中。实际上，**不论Value是5种类型的哪一种，都是通过redisObject来存储的**
> redisObject中的type字段指明了Value对象的类型，ptr字段则指向对象所在的地址。不过可以看出，字符串对象虽然经过了redisObject的包装，但仍然需要通过SDS存储

### DicEntry 内存分配
- 无论是DictEntry对象，还是redisObject、SDS对象，都需要内存分配器（如jemalloc）分配内存进行存储。
- 以DictEntry对象为例，有3个指针组成，在64位机器下占24个字节，jemalloc会为它分配32字节大小的内存单元

## RedisObject
- **Redis 并没有直接使用基础的数据结构来实现键值对的数据库**，而是在这些数据结构之上又包装了一层RedisObject（对象），RedisObject 有五种对象：字符串对象、列表对象、哈希对象、集合对象和有序集合对象。

### 使用 RedisObject 的好处
- 通过不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。
- 我们可以针对不同的使用场景，为对象设置不同的实现，从而优化内存或查询速度。
- RedisObject对象非常重要，Redis对象的类型、内部编码、内存回收、共享对象等功能，都需要redisObject支持，

### RedisObject 结构
```
typedef struct redisObject {
    // 类型
    unsigned type:4;
    // 编码
    unsigned encoding:4;
    // 对象最后一次被访问的时间
    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */
    // 引用计数
    int refcount;
    // 指向实际值的指针
    void *ptr;
} robj;
```
#### type
- type字段表示对象的类型，占4个比特,执行type命令时，便是通过读取RedisObject的type字段获得对象的类型

![image-20201125213859708](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:39:00-image-20201125213859708.png)

##### type 与命令匹配关系
- 当执行一个不匹配的命令的时候，redis 就是根据type 进行判断的。

#### encoding 
- encoding表示对象的内部编码，占4个比特。对于Redis支持的每种类型，都有至少两种内部编码，例如对于字符串，有int、embstr、raw三种编码。通过encoding属性，Redis可以根据不同的使用场景来为对象设置不同的编码，**大大提高了Redis的灵活性和效率**,**通过object encoding命令，可以查看对象采用的编码方式**，
- encoding 表示ptr指向的具体数据结构，即这个对象使用了什么数据结构作为底层实现。encoding 的取值范围如下
![image-20201125213925626](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:39:26-image-20201125213925626.png)
- 每种类型的对象都至少使用了两种不同的编码，对象和编码的对应关系如下

![image-20201125213945992](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:39:46-image-20201125213945992.png)

#### refcount
- refcount 表示引用计数，由于C语言并不具备内存回收功能，所以 Redis 在自己的对象系统中添加了这个属性，当一个对象的引用计数为0时，则表示该对象已经不被任何对象引用，则可以进行垃圾回收了。
- 当创建新对象时，refcount初始化为1；当有新程序使用该对象时，refcount加1；当对象不再被一个新程序使用时，refcount减1；当refcount变为0时，对象占用的内存会被释放。
> Java中由于引用计数法解决不了循环引用的问题，所以 Java 中使用了可达性分析算法。那么Redis有没有考虑循环引用的问题呢

- 可以使用 object refcount 查看对象的引用情况。

  ![image-20201125214013978](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:40:14-image-20201125214013978.png)

##### 共享对象

- Redis中被多次使用的对象(refcount>1)，称为共享对象。Redis为了节省内存，当有一些对象重复出现时，新的程序不会创建新的对象，而是仍然使用原来的对象。这个被重复使用的对象，就是共享对象。**目前共享对象仅支持整数值的字符串对象**。

![image-20201125214030957](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:40:31-image-20201125214030957.png)

###### 共享对象的实现
- Redis的共享对象目前只支持整数值的字符串对象。
- 之所以如此，实际上是对内存和CPU（时间）的平衡**，共享对象虽然会降低内存消耗，但是判断两个对象是否相等却需要消耗额外的时间**。对于整数值，判断操作复杂度为O(1)；对于普通字符串，判断复杂度为O(n)；而对于哈希、列表、集合和有序集合，判断的复杂度为O(n^2)。
- 虽然共享对象只能是整数值的字符串对象，**但是5种类型都可能使用共享对象**（如哈希、列表等的元素可以使用
- 就目前的实现来说，Redis服务器在初始化时，会创建10000个字符串对象，值分别是0~9999的整数值；当Redis需要使用值为0~9999的字符串对象时，可以直接使用这些共享对象。10000这个数字可以通过调整参数REDIS_SHARED_INTEGERS（4.0中是OBJ_SHARED_INTEGERS）的值进行改变。

#### lru
- 表示对象最后一次被命令程序访问的时间。占据的比特数不同的版本有所不同（如4.0版本占24比特，2.6版本占22比特）。
- 通过对比lru时间与当前时间，可以计算某个对象的空转时间；object idletime命令可以显示该空转时间（单位是秒）。object idletime命令的一个特殊之处在于它不改变对象的lru值。

![image-20201125214055334](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:40:55-image-20201125214055334.png)

##### lru 与内存回收

### 基本数据类型表示
#### 字符串对象（string）
- 如果一个字符串对象保存的是整数值，并且这个整数值可以用 long 类型标识，那么字符串对象会讲整数值保存在 ptr 属性中，并将 encoding 设置为 int。
- set number 10086。那么 number 键对象的示意图如下

![image-20201125214111193](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:41:11-image-20201125214111193.png)

#### 哈希对象（hash）

![image-20201125214132258](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:41:32-image-20201125214132258.png)

## Reids 数据类型
- Redis 是一种键值（Key-Value）数据库。相对于关系型数据库（比如 MySQL），Redis 也被叫作非关系型数据库
- Redis 中，**键的数据类型是字符串**，但是为了丰富数据存储的方式，方便开发者使用，值的数据类型有很多，常用的数据类型有这样几种，它们分别是字符串、列表、字典、集合、有序集合。




redis 的每种数据类型都有多种实现，每种数据类型都至少有两种以上不同的实现方式

![image-20201125214158633](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:41:59-image-20201125214158633.png)
- 可以改进内部编码，而外部使用者无感知
- 在不同的使用场景下，选择不同的实现发挥各自的优势(会自动切花实现方式)




### 字符串
- 字符串最大单值512M

#### 内部编码

##### int
- 8字节的长整型

##### raw
- 大于等于39 字节的字符串
- 用简单动态字符串（SDS）来保存，将这个字符串的对象编码设置为raw


##### embsetr
- 小于等于39字节的字符串
    1. embstr编码将创建字符串对象所需的空间分配的次数从raw编码的两次降低为一次。
    2. 释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码对象的字符串对象需要调用两次内存释放函数
    3. 因为embstr编码的字符串对象的所有数据都保存在**一块连续的内存里面**，所以这种编码的字符串对象比起raw编码的字符串对象能更好地利用缓存带来的优势。

#### 使用场景
##### 缓存功能
##### 计数
##### 共享SESSION
##### 限速
```
private boolean accessLimit(String ip, int limit, int time, Jedis jedis) {
    boolean result = true;

    String key = "rate.limit:" + ip;
    if (jedis.exists(key)) {
        long afterValue = jedis.incr(key);
        if (afterValue > limit) {
            result = false;
        }
    } else {
        Transaction transaction = jedis.multi();
        transaction.incr(key);
        transaction.expire(key, time);
        transaction.exec();
    }
    return result;
}
```

### 列表（list）
- 列表这种数据类型支持存储一组数据。这种数据类型对应两种实现方法，一种是压缩列表（ziplist），另一种是双向循环链表。
#### 内部编码

##### ziplist(压缩列表)
- 当列表中存储的数据量比较小的时候，列表就可以采用压缩列表的方式实现。具体需要同时满足下面两个条件：
    - 列表中保存的单个数据（有可能是字符串类型的）小于 64 字节
    - 列表中数据个数少于 512 个。

- 它并不是基础数据结构，而是 Redis 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。
- 不过，它跟数组不同的一点是，它允许存储的数据大小不同。具体的存储结构也非常简单

![image-20201125214236499](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:42:37-image-20201125214236499.png)
- 听到“压缩”两个字，直观的反应就是节省内存。之所以说这种存储结构节省内存，是相较于数组的存储思路而言的。
- 我们知道，数组要求每个元素的大小相同，如果我们要存储不同长度的字符串，那我们就需要用最大长度的字符串大小作为元素的大小（假设是 20 个字节）。那当我们存储小于 20 个字节长度的字符串的时候，便会浪费部分存储空间

![image-20201125214254922](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:42:55-image-20201125214254922.png)
- 压缩列表这种存储结构，一方面比较节省内存，另一方面可以支持不同类型数据的存储。
- 而且，因为数据存储在一片连续的内存空间，通过键来获取值为列表类型的数据，读取的效率也非常高。

##### linkedlist（链表）
- 当列表中存储的数据量比较大的时候，也就是不能同时满足刚刚讲的两个条件的时候，列表就要通过双向循环链表来实现了
-  **压缩列表不支持随机访问**。有点类似链表。但是**比较省存储空间**啊。Redis一般都是通过key获取整个value的值，也就是整个压缩列表的数据，并不需要随机访问。

###### 双向循环链表
- Redis 的这种双向链表的实现方式，非常值得借鉴。它额外定义一个list结构体，来组织链表的首、尾指针，还有长度等信息。这样，在使用的时候就会非常方便

```
// 以下是C语言代码，因为Redis是用C语言实现的。
typedef struct listnode {
  struct listNode *prev;
  struct listNode *next;
  void *value;
} listNode;


typedef struct list {
  listNode *head;
  listNode *tail;
  unsigned long len;
  // ....省略其他定义
} list;
```

##### quicklist
- Redis3.2 版本提供了quicklist，结合了linkedlist和ziplist 的优势

#### 使用场景
- lpush+rpop 队列
- lpush+lpop 栈
- lpush+ltrim 有限集合
- lpush+rbop 消息队列

##### 消息队列
- 生产者使用lpush,消费者使用brpop(阻塞消费)

##### 文章列表
- list 不但是有序的，还支持按索引范围操作

### 字典（hash）
- 字典类型用来存储一组数据对。每个数据对又包含键值两部分。字典类型也有两种实现方式。一种是我们刚刚讲到的**压缩列表，另一种是散列表**。

#### 内部编码
##### ziplist(压缩列表)
- 只有当存储的数据量比较小的情况下，Redis才使用压缩列表来实现字典类型。具体需要满足两个条件：
    - 字典中保存的键和值的大小都要小于 64 字节；
    - 字典中键值对的个数要小于 512 个
- ziplist使用更加紧凑的结构实现多个元素的连续存储，所以**在节省内存方面比hashtable更加优秀，但是读写下利率会下降**

##### hashtable
- 当不能同时满足上面两个条件的时候，Redis 就使用散列表来实现字典类型。
- Redis 使用MurmurHash2这种运行速度快、随机性好的哈希算法作为哈希函数。对于哈希冲突问题，Redis 使用链表法来解决。
- 除此之外，Redis 还支持散列表的动态扩容、缩容，当数据动态增加之后，散列表的装载因子会不停地变大。为了避免散列表性能的下降，当装载因子大于 1 的时候，Redis 会触发扩容，将散列表扩大为原来大小的 2 倍左右（具体值需要计算才能得到）
- 当数据动态减少之后，为了节省内存，当装载因子小于 0.1 的时候，Redis 就会触发缩容，缩小为字典中数据个数的大约 2 倍大小（这个值也是计算得到的）
- 扩容缩容要做大量的数据搬移和哈希值的重新计算，所以比较耗时。针对这个问题，Redis使用我们在散列表（中）讲的**渐进式扩容缩容策略，将数据的搬移分批进行，避免了大量数据一次性搬移导致的服务停顿**。

#### 使用场景
##### 缓存功能
- 在对一些对象进行缓存的时候，hash 结构更加直观，而且在操作上更加便捷，可以直接操作具体的属性

#### MurmurHash 哈希函数
- 是一种非加密型哈希函数，适用于一般的哈希检索操作，与其它流行的哈希函数相比，对于规律性较强的key，MurmurHash的随机分布特征表现更良好

### 集合（set）
- 集合这种数据类型用来存储一组不重复的数据。这种数据类型也有两种实现方法，**一种是基于有序数组，另一种是基于散列表**。

#### 内部编码
##### intset(整数集合)
- 当要存储的数据，同时满足下面这样两个条件的时候，Redis就采用有序数组，来实现集合这种数据类型。
    -  存储的数据都是整数
    -  存储的数据元素个数不超过 512 个。

##### hashtable 
- 当不能同时满足这两个条件的时候，Redis 就使用散列表来存储集合中的数据。

#### 使用场景
##### 标签
- 给用户打各种各样的标签，这个时候我们有两种操作，一种是给用户打标签，另外一种是给标签添加用户

##### 社交
- 用来维护社交的用户的好友

### 有序集合（zset）
- 有序集合这种数据类型，它用来存储一组数据，并且每个数据会附带一个得分。通过得分的大小，我们将数据组织成跳表这样的数据结构，以支持快速地按照得分值、得分区间获取数据。

#### 内部编码
##### ziplist(压缩列表)
- 实际上，跟 Redis 的其他数据类型一样，有序集合也并不仅仅只有跳表这一种实现方式。**当数据量比较小的时候，Redis 会用压缩列表来实现有序集合**。具体点说就是，使用压缩列表来实现有序集合的前提，有这样两个：
    - 所有数据的大小都要小于 64 字节
    - 元素个数要小于 128 个。

##### 跳表
- 为压缩列表的读写性能不好，所以当数据量大的时候就开始采用跳表

#### 使用场景
##### 排行榜

- 有序集合适用于各种各样的单指标排行榜，点赞数排行榜、播放量排行榜

![image-20201125214322782](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:43:23-image-20201125214322782.png)
> 默认是按照分数升序排列的；当score即得分一样时，按照字典顺序对member进行排序，字典排序用的是二进制，它比较的是字符串的字节数组，所以实际上是比较ASCII码。

#### 需求(例子)
> 应用商店按照APP的下载量倒序排序，如果下载量一样，则按照最后更新时间倒序排列。

##### 有一定延时的方案
- 这个方案并不需要依赖SortedSet，它的实现非常简单，但是需要产品做简单的妥协，即不能实时更新榜单。其实现方案是：定时每隔1分钟（可以由产品确定时间间隔）通过SQL（select * from tb_apps order by download_count desc, updated_time desc limit 300）或者其他方式计算热门榜单，然后把TOP300用List结构保存到缓存中。
> 这种方案虽然简单，但是非常有用。即使不能做到实时，但是并没有影响用户体验。在项目初期需要快速发布，是一个比较推荐的做法

##### 利用SortedSet实现多维度排序

- SortedSet排序因子score，它是一个双精度64位的浮点型数字字符串。+inf和-inf都是有效值，能包括的整数范围是-(2^53) 到 +(2^53)，或者说是-9007199254740992 到 9007199254740992。
- 如何实现多维度排序呢,答案是构造一个特殊的score。以本文案例为例，排序影响因子是下载量和更新时间，那么我们可以构造一个这样特殊的浮点类型的score：整数部分就是下载量，小数部分就是最后更新时间戳

```
wechat-下载量：12000000，最后更新时间：1564022201；其score为：12000000.1564022201
qq-下载量：12000000，最后更新时间：1564022222；其score为：12000000.1564022222
tiktok-下载量：9808900，最后更新时间：1563552267；其score为：9808900.1563552267
taobao-下载量：11006600，最后更新时间：1564345601；其score为：11006600.1564345601
alipay-下载量：11006600，最后更新时间：1564345600；其score为：11006600.1564345600
```
> zadd TopApp 12000000.1564022201 wechat 12000000.1564022222 qq 9808900.1563552267 tiktok 11006600.1564345601 taobao 11006600.1564345600 alipay

![image-20201125214358270](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:43:58-image-20201125214358270.png)

###### 扩展
- 这种讨巧的方式只能实现二维排序。如果有三维排序，四维排序呢？这里笔者提供一种实现参考，即自定义得分权重计算公式，这个公式包含所有影响排序的因子，例如：downloadCount*1000+updatedTime。这种实现无论排序维度多少都搞得定，但是需要注意的是，在具体实现时一定注意不要让score溢出。


### Bitmaps
- 用**位数组**来表示各元素是否出现，每个元素对应一位，所需的总内存为n bit。能大大减少内存占用且位操作迅速。
- 如果要统计1亿个数据的基数值，大约需要内存100000000/8/1024/1024 ≈ 12M，内存减少占用的效果显著
- 但还是不够，统计一种场景需要12M(uv 或者 pv)，如果统计10000个场景，就需要将近120G了，同样不能广泛用于大数据场景

#### 适用场景
##### 用户签到
- 以用户ID为KEY，以当前时间距离开始时间的时间差为偏移量，若用户签到一次，则将位置为 1。
- 最后 bitcountKEY，获取用户一共签到的次数。

##### 统计活跃用户
- 需求：统计某天或连续几天，活跃用户数
- 方案：若某用户上线，则以日期为KEY，以用户user_id为偏移量（若ID不为整数，则将IDhash化为唯一ID），设置位为 1
- 计算7天内登录过的活跃用户：bitop OR result Monday Tuesday Wednesday Thursday Friday Saturday Sunday

##### 用户在线状态
- 在线设为一，不在线设为0

#### 总结
- bitmap 不适用大量非空数据，例如如果一个一亿用户的网站，但是每天活跃用户不足10w 的，这种情况下就不适合了

### HyperLogLog
- Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog是一种算法，它提供了**不精确的去重计数方案**
- 大数据量背景下，要实现基数计数，首先需要确定存储统计数据的方案，以及如何根据存储的数据计算基数值；另外还有一些场景下需要**融合多个独立统计的基数值**

> 例如对一个网站分别统计了三天的UV，现在需要知道这三天的UV总量是多少，怎么融合多个统计值。

> 假如我要统计网页的UV（浏览用户数量，一天内同一个用户多次访问只能算一次），传统的解决方案是使用Set来保存用户id，然后统计Set中的元素数量来获取页面UV。但这种方案只能承载少量用户，一旦用户数量大起来就需要消耗大量的空间来存储用户id。我的目的是统计用户数量而不是保存用户，这简直是个吃力不讨好的方案！而使用Redis的HyperLogLog最多需要12k就可以统计大量的用户数，尽管它大概有0.81%的错误率，但对于统计UV这种不需要很精确的数据是可以忽略不计的

![image-20201125214433493](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:44:34-image-20201125214433493.png)

#### HyperLogLog 的优化 
- Redis 对 HyperLogLog 的存储进行了优化，在计数比较小时，它的存储空间采用稀疏矩阵存储，空间占用很小，仅仅在计数慢慢变大，稀疏矩阵占用空间渐渐超过了阈值时才会一次性转变成稠密矩阵，才会占用 12k 的空间

#### HyperLogLog的优点
- 在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的,HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身
- 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。

####  HyperLogLog的不足
- 基数估计的结果是一个带有 0.81% 标准错误（standard error）的近似值
- 不保存元素，不能像集合一样返回元素

####  HyperLogLog的使用场景
- 基数不大，数据量不大就用不上，会有点大材小用浪费空间
- 有局限性，就是只能统计基数数量，而没办法去知道具体的内容是什么
- 和bitmap相比，属于两种特定统计情况，简单来说，HyperLogLog 去重比bitmap方便很多，一般可以bitmap和hyperloglog配合使用，bitmap标识哪些用户活跃，hyperloglog计数

##### 例子
1. 统计注册 IP 数
2. 统计每日访问 IP 数
3. 统计页面实时 UV 数
4. 统计在线用户数
5. 统计用户每天搜索不同词条的个数


### GEO 
- GEO功能在Redis3.2版本提供，支持存储地理位置信息用来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能.geo的数据类型为zset

#### geoadd
![image-20201125214501937](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:45:02-image-20201125214501937.png)
#### geopos/geodist
![image-20201125214518986](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:45:19-image-20201125214518986.png)
#### georadius
- 以给定的经纬度为中心,返回键包含的位置元素当中,与中心的距离不超过给定最大距离的所有位置元素。

![image-20201125214530739](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:45:31-image-20201125214530739.png)

#### georadiusbymember
- 这个命令和georadius命令一样,都可以找出位于指定范围内的元素,但是georadiusbymember的中心点是由给定的位置元素决定的,

  

![image-20201125214551686](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:45:52-image-20201125214551686.png)

#### zrem



![image-20201125214604325](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/25/21:46:04-image-20201125214604325.png) 
    

###

## 为什么要采用压缩列表实现
- 压缩列表不支持随机访问。有点类似链表。但是比较省存储空间啊。Redis一般都是通过key获取整个value的值，也就是整个压缩列表的数据，并不需要随机访问。
- 数据量小时采用连续内存的数据结构是为了CPU缓存读取连续内存来提高命中率，而限制数据数量和数据大小应该是考虑到CPU缓存的大小
- 压缩列表是数组的升级版，因为数组需要占用连续的内存空间，所以当数据量大的时候，就需要使用链表了

### Stream

## 数据结构的持久化问题/对象的持久化问题
### 清除原有格式
- 第一种是清除原有的存储结构，只将数据存储到磁盘中。当我们需要从磁盘还原数据到内存的时候，再重新将数据组织成原来的数据结构。实际上，Redis 采用的就是这种持久化思路。
- 这种方式也有一定的弊端。那就是数据从硬盘还原到内存的过程，会耗用比较多的时间。比如，我们现在要将散列表中的数据存储到磁盘。当我们从磁盘中，取出数据重新构建散列表的时候，需要重新计算每个数据的哈希值。如果磁盘中存储的是几 GB 的数据，那重构数据结构的耗时就不可忽视了

### 保留原来的存储格式
- 第二种方式是保留原来的存储格式，将数据按照原有的格式存储在磁盘中。
- 我们拿散列表这样的数据结构来举例。我们可以将散列表的大小、每个数据被散列到的槽的编号等信息，都保存在磁盘中。
- 有了这些信息，我们从磁盘中将数据还原到内存中的时候，就可以避免重新计算哈希值。