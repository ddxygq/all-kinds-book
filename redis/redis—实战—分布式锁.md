[toc]

[link](http://www.imooc.com/read/75/article/1815)
## 分布式锁的背景
- 总结来说就是**分布式系统要访问共享资源**，为了避免并发访问资源带来错误，我们为共享资源添加一把锁，让各个访问互斥，保证并发访问的安全性，这就是使用分布式锁的原因。
- 当多个进程不在同一个系统中，就需要用分布式锁控制多个进程对资源的访问
- 传统的锁(比如编程语言里的lock)，都是对多线程进行控制，但是对多进程、或者多客户端就无能为力了，为此，就诞生了分布式锁。
- 还有其他的实现方式，基于数据库乐观锁,基于ZooKeeper的分布式锁

## 基本原理
- redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对redis的连接并不存在竞争关系。

## 实现
- redis中使用分布式锁很简单，只要使用setnx指令对某个key上锁就行：
> setnx lock test //上锁 

> del lock test   //解锁
- 当某个key没有被占用的时候，setnx指令会返回1，否则返回0，这就是Redis中分布式锁的使用原理。

### 问题一 客户端上锁之后没有解锁
- 客户端上锁之后，因为种种原因没有解锁(挂掉了)，可以在上锁之后使用expire指令给锁设置过期时间

### 问题二 客户端上锁之后没设置锁的过期时间
- 如果靠redis设置时间过期来解锁，貌似会出问题。假如我们的服务进程在**执行setnx之后和执行expire指令之前挂掉了**，这个锁也永远没办法解了
> 这确实是个问题，当时人们在Redis的开源社区提出了一堆解决方案专门来解决这个问题，可实现方式都极为复杂。后来Redis的作者在Redis 2.8版本中加入了set指令的扩展参数，使得setnx指令和expire指令能够同时执行

- set lock test ex 5 nx
> ex：设置键的过期时间

> nx：只在键不存在时，才对键进行设置操作

### 问题三 分布式锁在Redis集群中遇到的麻烦
- 在企业中，Redis基本上都是集群部署的，集群部署避免不了要面对某个节点宕机的问题。假设我们在redis的主节点上添加了一把分布式锁，不幸的是主节点挂掉了，而且**主节点上的锁还没有同步到从节点上，如果此时有客户端来请求获得同一把锁，那么它将顺利地获得锁，之前那把锁会被无情地忽视掉，这就是分布式锁在Redis集群中遇到的麻烦**

#### 解决方案
- Redis的作者为了解决这个问题提出了一个叫Redlock的算法，它的原理是这样的：当上锁的时候，把set指令发送给过半的节点，只要过半的锁set成功，就认为这次加锁成功；当解锁的时候，会向所有的节点发送del指令。
- 从这个算法的原理可以看出，由于Redlock需要同时对多个节点进行读写，**因此使用Redlock加分布式锁的性能要比单机Redis低很多**。**因为主从复制出纰漏的概率极低，所以如果对分布式加锁过程有一定的容错率的话，可以考虑直接使用set指令；如果追求高可用性，可以考虑使用Redlock算法**。

- 当然，高可用性的分布式锁不只有Redis的Redlock，我们还可以用zookeeper或者支持事务的数据库做分布式锁。

## 扩展
- 虽然Redis是以集群的方式部署的，但还是使用最基本的set指令获取分布式锁，因为这种方式的性能远远高于Redlock算法，也高于zk，数据库等分布式锁实现方式

### zookeeper的分布式锁原理
- 假设zk用某个节点作为分布式锁，当不同的客户端到zk竞争这把锁的时候，**zk会按顺序给不同的客户端创建一个子节点，挂在作为分布式锁的节点下面**。**假设第一个来到的客户端为A，第二个来到的是B，分布式节点下挂的第一个节点就是A，B紧跟着A，且B会监听着A的生命状态，当A释放锁后A会被删除，这时B监听到A被删除，B接能上位获得分布式锁了**。

### Lua 脚本
- Redis 通过调用 Lua 脚本，可以实现更加强大与复杂的功能。而且在执行 Lua 脚本的时候操作具有原子性。这恰好可以用来实现分布式锁

### Redission
- Redission 是一个基于 Redis 的第三方组件，提供了很多强大的功能，也是 Redis 官方推荐的分布式锁解决方案。基于一种叫做 RedLock 的算法实现的分布式锁，比起我们自己实现分布式锁，Redission 更加的安全可靠，所以在生产环境中更加推荐使用 Redission 来作为分布式锁的解决方案。
```
Config config = new Config();
config.useSentinelServers().addSentinelAddress("127.0.0.1:6479", "127.0.0.1:6489").setMasterName("master").setPassword("password").setDatabase(0);
RedissonClient redisson = Redisson.create(config);


RLock lock = redisson.getLock("test_lock");
try{
    boolean isLock=lock.tryLock();
    if(isLock){
        doBusiness();
    }
}catch(exception e){
}finally{
    lock.unlock();
}
```