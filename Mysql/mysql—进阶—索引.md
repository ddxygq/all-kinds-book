[toc]
# 索引
- 数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。
## 数据和索引的位置
### 聚簇索引
- 聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针
- 聚簇索引中的每个叶子节点包含主键值、事务ID、回滚指针(rollback pointer用于事务和MVCC）和余下的列
- 际存储的循序结构与数据存储的物理机构是一致的，所以通常来说物理顺序结构只有一种，那么一个表的聚簇索引也只能有一个，通常默认都是主键，设置了主键，系统默认就为你加上了聚簇索引
- 聚簇索引并不是一种索引的类型，而是一种数据存储的方式，集体的实现还是要看不同的存储引擎

#### innoDB
- InnoDB是聚集索引，使用B+Tree作为索引结构，**数据文件是和（主键）索引绑在一起的**（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。
- 但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，**主键不应该过大，因为主键太大，其他索引也都会很大**(因为主键索引和辅助索引是对应的)。

```
如果你为表定义了一个主键，MySQL将使用主键作为聚簇索引。
如果你不为表指定一个主键，MySQL讲索第一个组成列都not null的唯一索引作为聚簇索引。
如果InnoBD表没有主键且没有适合的唯一索引（没有构成该唯一索引的所有列都NOT NULL），MySQL将自动创建一个隐藏的名字为“GEN_CLUST_INDEX ”的聚簇索引
```

### 非聚簇索引
- 非聚簇索引记录的物理顺序与逻辑顺序没有必然的联系，与数据的存储物理结构没有关系；一个表对应的非聚簇索引可以有多条，根据不同列的约束可以建立不同要求的非聚簇索引

#### Myisam
- MyISAM是非聚集索引，也是使用B+Tree作为索引结构，**索引和数据文件是分离的**，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

## 索引的优点
- 大大减少了服务器需要扫描的数据量
- 可以帮助服务器避免排序和临时表(B-tree 的数据时有序的)
- 将随机IO 变成顺序IO

### 如何评价索引
- 索引并不是最好的工具，对于小表来说不需要，对于特大表来说维护成本太高
- 对于大型的表可以使用分区(例如数仓表)，通过筛选出需要的一组数据而不是一条条的比较筛选
- 对于表特别多的系统，可以设计元数据系统

### 索引的三星系统
```
判断一个索引是否适合查询的"三星系统"
```
#### 一星
- 索引将相关的记录放在了一起

#### 二星
- 索引中的数据顺序和查找中的排序顺序一致

#### 三星
- 如果索引列中包含了了查找需要的所有数据

# 索引的数据结构
- 二叉树(Binary Tree)-->二叉搜索数 BST(Binary Search Tree)-->平衡二叉树（AVL Tree）——> 红黑数

## Hash
- hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据。
### 优势
1. hash 检索的效率更高，通常一次交互即可(其实hash 索引肯定是需要回表的)
### 不足
1. . hash 不能进行范围查询
2. . hash 不能使用联合索引(Hash值是针对联合索引建合并后一起来计算Hash值，因此无法对单独的一个键或者几个索引键进行查询)
3. hash 不能进行排序
4. hash 不能进行模糊查询
5. 不适合在值重复很多的列上建立(但是是支持的Memory 是唯一支持非唯一哈希索引的)
6. hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差

### 自适应hash 索引
- mysql innodb 有个自适应哈希索引,某个索引值使用非常频繁的时候，会在B+树的基础上建立hash 索引;虽然Hash索引的使用场景有很多限制，但是优点也很明显，所以MySQL提供了一个自适当Hash索引的功能（Adaptive Hash index）。注意，这里的自适应指的是不需要人工来制定，而是系统根据情况来自动完成的。但是可以关闭该功能

### 自适应哈希索引
- 在B-tree 的索引中，如果某个数据经常会访问到，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。需要说明的是：
    -   1）自适应哈希索引只保存热数据（经常被使用到的数据），并非全表数据。因此数据量并不会很大，可以让自适应Hash放到缓冲池中，也就是InnoDB buffer pool，进一步提升查找效率。
    -   2）InnoDB中的自适应Hash相当于是“索引的索引”，采用Hash索引存储的是B+树索引中的页面的地址。这也就是为什么可以称自适应Hash为索引的索引。采用自适应Hash索引目的是可以根据SQL的查询条件加速定位到叶子节点，特别是当B+树比较深的时候，通过自适应Hash索引可以提高数据的检索效率。
    -  3）自适应Hash采用Hash函数映射到一个哈希表中，所以对于字典类型的数据查找非常方便
    哈希表是数组+链表的形式。通过Hash函数可以计算索引键值所对应的bucket（桶）的位置，如果产生Hash冲突，如果产生哈希冲突，就需要遍历链表来解决。
    - 4）是否开启了自适应Hash，可以通过innodb_adaptive_hash_index变量来查看，比如：mysql> show variables like '%adaptive_hash_index';
- 所以，总结下InnoDB本身不支持Hash，但是提供自适应Hash索引，不需要用户来操作，而是存储引擎自动完成的。自适应Hash也是InnoDB三大关键特性之一，另外两个分别是插入缓冲（Insert Buffer）和二次写(Double Write)。

### 如何手动建立HASH索引
- 需要注意的是InnoDB 的自适应哈希索引是自动的，不受用户管控的，而支持hash 索引的只有Memory 和NDB集群引擎
- 可以通过在插入数据的时候，同时插入数据和要被索引字段的hash 值，查询的时候根据hash函数的值来进行hash 值所在列进行过滤

#### 例子
- create table hashurl(url varchar(30),hash bigint primary key);
```
也不一定非要当成主键，可以当成唯一索引或者普通的索引(有多条)
```
- insert into hashurl values ('www.sougou1.com',crc32('www.sougou1.com'));
- insert into hashurl values ('www.sougou2.com',crc32('www.sougou2.com'));
- insert into hashurl values ('www.baidu.com',crc32('www.baidu.com'));
- select * from hashurl where hash=crc32('www.baidu.com');

![image-20201127214210588](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/27/21:42:11-image-20201127214210588.png)

```
如果是普通索引的情况下，加上crc32() 可能存在hash 冲突，这个时候争取的sql 写法
select * from hashurl where hash=crc32('www.baidu.com') and url='www.baidu.com';
```
- 需要注意的是
    - 可以使用触发器完成对索引的维护，而不是在插入的时候进行维护
    - hash 函数不要使用SHA1() 和 MD5() 因为它们生成的hash 值很大，因为它们的涉及目标是最大限度消除hash 冲突。
    - 如果表的数据量和很大，这个时候crc32会发生大量的hash 冲突(crc32 是32位hash 函数)，则可以考虑自己实现一个简单的64位hash 函数，只不过要求返回的实整数，一个简单的办法是可以利用MD5()函数的返回值的一部分进行hash,例如 crc32(right(md5('XXXX'),10));
    - 

## 多路平衡查找数
### 二叉树搜索树
- 二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。
#### 不足
- 一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。
- N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。

### B-树(平衡多路查找树)
![image-20201127214232742](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/27/21:42:33-image-20201127214232742.png)
### B+ 树
![image-20201127214249069](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/27/21:42:49-image-20201127214249069.png)
- B+ 树非叶子节点不存储数据
1. 查询更稳定
2. 效率更高（减少和磁盘交互的次数）
    - B树的每个节点含有卫星数据，而B+树中间节点含有指向卫星数据的指针，叶子节点才存有卫星数据。这样一来每次进行B+树查询都需要查询到叶子节点，性能更稳定，而且B+树节点只存储指向卫星数据的指针，这样一个磁盘页能存储更多节点。
3. 查询效率高（更适合范围查询，B 数需要中序遍历）

#### 效率的推算
- 可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：
- InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。
- 实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。

#### B+树的检索方式
1. 从根节点开始检索，找到对应的数据页
2. 加载整个数据页到内存，然后进行二分检索，确定组，最后再在组内进行遍历

#### 为什么选择B+数做索引
- hash 不支持范围查询且存在着Hash 冲突
- 二叉搜索树性能不高
- B树在性能上不稳定，并且不太适合范围查询

### B+ 和 B 的区别
1. B树非叶子结点存储数据；B+树非叶子结点不存储数据只存索引。
2. B树叶子结点没有使用双向链表串连；B+树叶子结点使用双向链表进行串连，为了支持区间查询。

## 分形索引树
## 有序数组
- 如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高
- 有序数组索引只适用于静态存储引擎

## 跳表
## LSM 树



# 其他索引
## 空间数据索引
- mysql 的GIS 并不完善
## 全文索引
- 全文索引查找的实文本中的关键词，而不是直接比较索引中的值，全文索引更类似于搜索引擎

# mysql 的索引
- 在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。根据叶子节点的内容，索引类型分为主键索引和非主键索引
- **主键索引的叶子节点存的是整行数据**。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。
- 非主键索引的叶子节点内容是索引列和主键的值。**在InnoDB里，非主键索引也被称为二级索引（secondary index）或辅助索引**。
- 一张InnoDB表必须有一个聚簇索引，当有主键时，会以主键作为聚簇索引；如果没有显式定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，则MySQL自动为InnoDB表生成一个隐含字段作为主键。**除聚簇索引外的其他索引都可称为二级索引，比如我们常用到的唯一索引、普通索引、联合索引等**。

## 主键索引
## 辅助索引

## 普通索引
## 唯一索引
## 组合索引
### 最左匹配原则
- 类似你买东西的时候填写收货地址的过程，必须写省份、然后写市、最后写县级 
## 全文索引
## 其他

### 谓词下推
### 索引下推
- mysql5.6 之前，都是将数据从存储层拉到服务层，然后再去进行过滤
- mysql5.6 之后，再存储引擎层进行数据过滤然后再返回给服务层

### 回表
- 先去普通索引里查主键，然后根据主键再根据主键去查询

### 覆盖索引
- 查询的字段就是索引
    -   在辅助索引上查找主键
    -   在主键上查找索引字段
- 需要注意一下的是，有时候索引覆盖是不用回表的原因，这二者之间不是完全没有关系的

#### 意义
- 比起数据，索引的的通常远远小于数据条目，所以可以降低磁盘IO,
- 对于InnoDB 的二级索引而言，可以避免对主键索引的访问(不用回表了，本来是需要的)

#### 可以支持的条件
- 覆盖索引的必要条件是，索要要存储索引列的值，而哈希索引、空间索引、全文索引都是不存索引列的值的
- MySQL 只能使用B-tree 做覆盖索引
- 不是所有的引擎都支持覆盖索引

### 普通索引和唯一索引的区别
- 对于唯一索引来说，由于索引上有唯一性，查询到第一个满足条件的记录后就停止检索了;普通索引来说，查询到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足的记录

#### 对性能的影响
- 微乎其微，几乎可以忽略不计
- 在innodb中，每个数据页的大小默认是16KB，因为引擎是按页读写的，所以找到某条记录的时候，会把改记录所在的数据页全部读取进来，所以同一个键值的数据大概率的情况下是在一个页上的。
- 这个时候，从页上遍历选取一条记录还是多条记录都是在内存中进行操作的，几乎可以忽略

### 压缩(前缀压缩)索引
- Myisam 使用前缀来压缩索引，从而可以让更多的索引放入内存，以提高效率。默认情况下**只能压缩字符串**，但通过参数设置可以对整数进行压缩
- Myisam 对行指针也采取了类似的压缩方式

#### 原理
- 先完全保存索引块中的第一个值，然后其他值和第一个值进行比较得到相同的前缀和剩余不同的后缀，然后把公共的前缀存储起来即可
```
例如，索引中的第一个值是 perform，第二个值是performance，然后得到前缀是 perform，那么第二个字符串压缩后的效果就是 '7,ance'
```

### 普通索引和唯一索引在查询上的不同
1. 由于数据库引擎回将数据所在的页一次性读入懂啊内存，所以唯一索引检索到了即停止，但是普通索引回进行多次判断，找到全部的被检索数据

### 自增主键的意义
- 避免了页分裂，提高了性能
- 自增主键往往是整型，可以降低二级索引的内存占用
#### 什么场景适合用业务字段直接做主键的呢
- 只有一个索引；该索引必须是唯一索引——kv 系统
- 由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题,但是依然存在页分裂对性能的影响。



# mysql 索引优化
- 正确创建和使用索引是性能优化的基础
- 索引优化主要指的是“走索引”

## 高性能索引的策略
### 非独立的列
- "独立的列"指的是mysql 的索引列不能是表达式的一部分，也不能是函数的参数

### 前缀索引和索引的选择性
- 索引很长的字符会让索引变得很大而且很慢
- 这里的前缀也不一定是真正意义上的前缀，也可能是后缀

#### 模拟hash 索引
- 例如url 的索引

#### 索引字符串开始的部分字符
- 这样可以节约索引空间，提高索引效率，但是这样会降低索引的选择性，索引的选择性越高，索引的性能越好
```
索引的选择性——索引的不重复值和数据表的总条数的比值
```
- 所以前缀索引的关键在于，选择足够长的前缀保证有较高的选择性，同时又不能太长

#### 前缀索引长度的选择计算公式
```
select count(distinct user_id)/count(*) as ref,count(distinct left(user_id,4))/count(*) as c1,count(distinct left(user_id,5))/count(*) as c2, count(distinct left(user_id,6))/count(*) as c3 from user_behavior;
```
![image-20201127214411868](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/27/21:44:12-image-20201127214411868.png)

- ref 是目标(完整列的选择性)，可以看到在签注的长度为6的时候再增加前缀索引的长度效果已经不那明显了
-  确定了前缀的长度，然后就是添加前缀索引了 alter table tmp add key(user_id(6));

### 多列索引

```
create table film_actor(film_id int,act_id int,key(film_id),key(act_id));
```
#### 索引合并(index merge)
- where 中可能有多个条件(或者join)涉及到多个字段，它们之间进行 AND 或者 OR，那么此时就有可能会使用到 index merge 技术。index merge 技术如果简单的说，其实就是：对多个索引分别进行条件扫描，然后将它们各自的结果进行合并(intersect/union)。
- 索引合并技术主要是针对对个单列索引,在早期的版本中可能要针对where 中 or 的条件进行转换成 union 的操作
```
select *  from film_actor where film_id=1 or act_id=1;
select *  from film_actor where  act_id=1 union all select * from film_actor where film_id=1 and act_id!=1;
```
#### 多列索引的选择标准
- 选择性高的放在前面，但这只是大多数情况下的一个通用的法则，并不是一个真正最优的选择，但不如避免随机IO和排序重要
- 需要考虑根据哪些运行最频繁的查询来考虑调整列的顺序

## mysql 选错索引了
### 统计信息有误
### mysql 考虑到了回表
- 当在一个索引字段常进行查询的时候，当时当这个索引的区分度不高或者根据你要的索引查询的数据量比较大
- 这个时候mysql则可能采取不走索引的方式直接全表扫描，否则要进行大量的回表
### mysql 考虑到了排序

### 解决方案
- 建立合适的索引，让mysql 的选择更容易
- force index 进行人为干预
- analyze table 进行统计信息更新

### 例子
#### mysql 统计信息错误
#### mysql 考虑到了排序
```
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `a` int(11) DEFAULT NULL,
  `b` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `a` (`a`),
  KEY `b` (`b`)
) ENGINE=InnoDB；
```
![image-20201127214437849](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/27/21:44:38-image-20201127214437849.png)
- 如果使用索引 a 进行查询，那么就是扫描索引 a 的前 1000 个值，然后取到对应的 id，再到主键索引上去查出每一行，然后根据字段 b 来过滤。显然这样需要扫描 1000 行。
- 如果使用索引 b 进行查询，那么就是扫描索引 b 的最后 50001 个值，与上面的执行过程相同，也是需要回到主键索引上取值再判断，所以需要扫描 50001 行。
- 通过force 命令使得mysql 可以走正确的索引(但是mysql 选择错误的原因是因为排序的问题，选择b的话可以不用排序)

![image-20201127214535999](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/2020/11/27/21:45:36-image-20201127214535999.png)
```
不喜欢使用 force index，一来这么写不优美，二来如果索引改了名字，这个语句也得改，显得很麻烦。而且如果以后迁移到别的数据库的话，这个语法还可能会不兼容。
```

## 干预索引
### force index 和 use index 的区别
- use index 只是给mysql优化器一种选择的可能,具体的mysql优化器再进行优化选择
- 但是 force index 是强制mysql优化器使用某个索引

## 索引失效
- 对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能
- 但是如果函数的参数字段是有索引的，还是会走索引，但是导致了全索引扫描。为了能够用上索引的快速定位能力，我们就要把 SQL 语句改成基于字段本身的范围查询
```
不过优化器在个问题上确实有“偷懒”行为，即使是对于不改变有序性的函数，也不会考虑使用索引。比如，对于 select * from tradelog where id + 1 = 10000 这个 SQL 语句，这个加 1 操作并不会改变有序性，但是 MySQL 优化器还是不能用 id 索引快速定位到 9999 这一行。所以，需要你在写 SQL 语句的时候，手动改写成 where id = 10000 -1 才可以。
```




### 条件字段函数操作
- select count(*) from tradelog where month(t_modified)=7;
- select count(*) from tradelog where
	(t_modified >= '2016-7-1' and t_modified<'2016-8-1') or
	(t_modified >= '2017-7-1' and t_modified<'2017-8-1') or 
	(t_modified >= '2018-7-1' and t_modified<'2018-8-1');
### 隐式类型转换
- select * from tradelog where tradeid=110717;
- select * from tradelog where  CAST(tradid AS signed int) = 110717;


### 隐式字符编码转换

select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2; /*语句Q1*/
字符集不同只是条件之一，连接过程中要求在被驱动表的索引字段上加函数操作，是直接导致对被驱动表做全表扫描的原因

select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2; 

## 重建索引
- 索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。
- 不论是删除主键还是创建主键，都会将整个表重建。所以就不要出现下面这种写法，因为前面那个语句白执行了
```
alter table T drop primary key;
alter table T add primary key(id);
```
- 正确重建索引的写法 alter table T engine=InnoDB

## 索引使用建议
- 显式创建主键索引，建议使用自增ID作为主键- 。
- 只为用于搜索、排序、分组、连接的列创建索- 引。
- 对经常更新的表避免创建过多的索引。
- 建立联合索引时，可选择性高的列放在前面。
- 尽量不要在可选择性差的列上建索引，如：性- 别、状态列等。
- 尽量使用覆盖索引进行查询，避免回表带来的- 性能损耗。（覆盖索引包含要查询的所有列）
- select后面只写查询需要用到的字段，去掉不- 需要的字段。
- 定位并删除表中的重复和冗余索引。


