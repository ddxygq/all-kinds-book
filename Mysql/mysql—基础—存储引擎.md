[toc]
## mysql 存储引擎
- 负责数据的存储和提取，是一种插件式的架构方式。支持 InnoDB、MyISAM、Memory 等多个存储引擎。MySQL 5.5.5版本开始默认存储引擎是 InnoDB，也是目前常用的存储引擎。
- show engines; 查看支持的引擎
- -存储引擎是表级别的，而不是DB级别的，所以我们可以为不同的表选择不同的存储引擎
- 存储引擎底层只有几十个接口，然后通过搭积木的方式完成整个查询，正是因为这种简单的接口设计，才使得mysql 的存储引擎可以设计为插拔式的结构。
- 不论是在事务支持、并发能力还是在数据安全方面，InnoDB 都优于 MyISAM

![存储引擎.png](WEBRESOURCEe412dbc339407a8ee694d2637e5fb957)
-  查看MySQL支持的存储引擎 mysql> show engines;

### 存储引擎核心
#### 数据的存储方式
- 系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。
- InnoDB存储引擎中有页（Page）的概念，**页是其磁盘管理的最小单位**。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：show variables like 'innodb_page_size'

![image](D832156E05A946A28D01E9056EC8107B)

##### 段(Segment)
-   分为索引段，数据段，回滚段等。
-   其中索引段就是非叶子结点部分，而数据段就是叶子结点部分，回滚段用于数据的回滚和多版本控制。一个段包含256个区(256M大小)。

##### 区
- 是页的集合，一个区包含64个连续的页，默认大小为 1MB (64*16K)。
##### 页
- 是 InnoDB 管理的最小单位，常见的有 FSP_HDR，INODE, INDEX 等类型。
- 所有页的结构都是一样的，分为文件头(前38字节)，页数据和文件尾(后8字节)。页数据根据页的类型不同而不一样。
    - FILE_SPACE_HEADER 页：用于存储区的元信息。ibd文件的第一页 FSP_HDR 页通常就用于存储区的元信息，里面的256个 XDES(extent descriptors) 项存储了256个区的元信息，包括区的使用情况和区里面页的使用情况。
    - IBUF_BITMAP 页：用于记录 change buffer的使用情况。
    - INODE 页：用于记录文件段(FSEG)的信息，每页有85个INODE entry，每个INODE entry占用192字节，用于描述一个文件段。每个INODE entry包括文件段ID、属于该段的区的信息以及碎片页数组。区信息包括 FREE(完全空闲的区), NOT_FULL(至少使用了一个页的区), FULL(没空闲页的区)三种类型的区的List Base Node(包含链表长度和头尾页号和偏移的结构体)。碎片页数组则是不同于分配整个区的单独分配的32个页。
    - INDEX 页：索引页的叶子结点的data就是数据，如聚集索引存储的行数据，辅助索引存储的主键值。


![image](39E93A807EFE4C61AA51F1BC6500B780)
- 系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。


#### 索引的存储方式
#### 锁的实现方式

### InnoDB
- MySQL 5.5 版本以后，默认存储引擎就是 InnoDB 了

#### InnoDB 的特性
- InnoDB是MySQL默认的**事务型引擎**，也是最重要、最广泛的存储引擎。
- 它的设计是用来处理**大量短期事务**，短期事务大部分是正常提交的，很少回滚。
- InnoDB的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中，也很流行。
- 除了非常特别的原因需要使用其他引擎，InnoDB也是非常好值得花时间研究的对象。
```
- 对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务
```
- 总之它的特性就是 事务处理、回滚、崩溃修复能力和多版本并发控制，缺点是读写效率较差，占用的数据空间相对较大。

##### 支持事务
- InnoDB 最重要的一点就是支持事务，可以说这是 InnoDB 成为 MySQL 中最流行的存储引擎的一个非常重要的原因。此外 InnoDB 还实现了 4 种隔离级别（READ UNCOMMITTED，READ COMMITTED，REPEATABLE READ 和 SERIALIZABLE），使得对事务的支持更加灵活。

##### 灾难恢复性好
- InnoDB 通过 commit、rollback、crash-recovery 来保障数据的安全。
具体来说，crash-recovery 就是指如果服务器因为硬件或软件的问题而崩溃，不管当时数据是怎样的状态，在重启 MySQL 后，InnoDB 都会自动恢复到发生崩溃之前的状态。

##### 使用行级锁
- InnoDB 改变了 MyISAM 的锁机制，实现了行锁。虽然 InnoDB 的**行锁机制是通过索引来完成的**，但毕竟在数据库中大部分的 SQL 语句都要使用索引来检索数据。行锁定机制也为 InnoDB 在承受高并发压力的环境下增强了不小的竞争力。

##### 实现了缓冲处理
- InnoDB 提供了专门的缓冲池，实现了缓冲管理，不仅能缓冲索引也能缓冲数据，常用的数据可以直接从内存中处理，比从磁盘获取数据处理速度要快。在专用数据库服务器上，通常会将最多80％的物理 memory 分配给缓冲池。

##### 外键约束
- InnoDB 支持外键约束，检查外键、插入、更新和删除，以确保数据的完整性。存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显式在表定义时指定主键，InnoDB 会为每一行生成一个6字节的 ROWID ，并以此作为主键。
#### InnoDB数据更新流程
- 先在Buffer Pool中更新，并将更新记录到 Redo Log 文件中，Buffer Pool中的记录会标记为脏数据并定期刷到磁盘。

#### InnoDB 的架构
![image](FA404047D0274891946E48F99C314951)
- InnoDB 的架构分为两块：**内存中的结构**和**磁盘上的结构**。InnoDB 使用日志先行策略，将数据修改先在内存中完成，并且将事务记录成重做日志(Redo Log)，**转换为顺序IO高效的提交事务**。

- 日志先行，说的是**日志记录到数据库以后，对应的事务就可以返回给用户，表示事务完成**。但是**实际上，这个数据可能还只在内存中修改完，并没有刷到磁盘上去**。内存是易失的，如果在数据落地前，机器挂了，那么这部分数据就丢失了。

- InnoDB 通过 redo 日志来保证数据的一致性。如果保存所有的重做日志，显然可以在系统崩溃时根据日志重建数据。
- redo log 必须在数据落盘前先落盘(Write Ahead Log)，从而保证数据持久性和一致性。而数据本身的修改可以先驻留在内存缓冲池中，再根据特定的策略定期刷到磁盘。

- 当然记录所有的重做日志不太现实，所以 InnoDB 引入了检查点机制。即定期检查，保证检查点之前的日志都已经写到磁盘，则下次恢复只需要从检查点开始。

##### 内存结构
- 内存中的结构主要包括** Buffer Pool，Change Buffer、Adaptive Hash Index以及 Log Buffer** 四部分。
- Change Buffer 和 Adaptive Hash Index 占用的内存都属于 Buffer Pool，Log Buffer占用的内存与 Buffer Pool独立。
- 基于效率考虑，InnoDB中数据管理的最小单位为页，默认每页大小为16KB，每页包含若干行数据。

###### Buffer Pool
- 缓冲池缓存的数据包括Page Cache、Change Buffer、Data Dictionary Cache等，通常 MySQL 服务器的 80% 的物理内存会分配给 Buffer Pool。
- 为了提高缓存管理效率，InnoDB的缓存池通过一个页链表实现，很少访问的页会通过缓存池的** LRU 算法**淘汰出去。
-  show engine innodb status; 查看一些引擎的信息

![image](A8D2DA0B38434463AB39BDF35AE739F4)

###### Change Buffer
- 通常来说，InnoDB辅助索引不同于聚集索引的顺序插入，如果每次修改二级索引都直接写入磁盘，则会有大量频繁的随机IO。
- Change buffer 的主要目的是将**对非唯一辅助索引页的操作缓存下来**，以此减少辅助索引的随机IO，并达到操作合并的效果。它会**占用部分Buffer Pool 的内存空间**。
-  MySQL5.5 之前 Change Buffer其实叫 Insert Buffer，最初只支持 insert 操作的缓存，随着支持操作类型的增加，改名为 Change Buffer。
-  如果辅助索引页**已经在缓冲区了，则直接修改即可**；如果不在，则先将修改保存到 Change Buffer。 ChangeBuffer的数据在对应辅助索引页读取到缓冲区时合并到真正的辅助索引页中。Change Buffer 内部实现也是使用的 B+ 树。

![image](D8F3E7DD2A7542F1BB388095F73713D2)

###### Adaptive Hash Index
- 自适应哈希索引(AHI)查询非常快，一般时间复杂度为 O(1)，相比 B+ 树通常要查询 3~4次，效率会有很大提升
- 。innodb 通过观察**索引页上的查询次数**，如果发现建立哈希索引可以提升查询效率，则会自动建立哈希索引，称之为自适应哈希索引，不需要人工干预，可以通过 innodb_adaptive_hash_index 开启，MySQL5.7 默认开启

![image](CE4B132B631345A69355ED6BB0D4D134)
- 有些系统开启自适应哈希索引可能会导致性能提升不明显，而且为监控索引页查询次数增加了多余的性能损耗， MySQL5.7 更改了 AHI 实现机制，每个 AHI 都分配了专门分区，通过 innodb_adaptive_hash_index_parts配置分区数目，默认是8个
![image](EAED69D26FC445F08ACE50C338C28CBF)

###### Log Buffer
- Log Buffer是 **重做日志在内存中的缓冲区**，大小由 innodb_log_buffer_size 定义，默认是 16M。
- 一个大的 Log Buffer可以让大事务在提交前不必将日志中途刷到磁盘，可以提高效率。如果你的系统有很多修改很多行记录的大事务，可以增大该值(配合前面的描述，mysql 为了提高性能不会立刻将数据写到磁盘，所以 redo log 是为了保证数据的一致性，事务提交的时候redo log 落盘，但是如果事务很大，redo log 可能需要在事务没有提交的时候进行落盘)
```
刷写其实是两个操作，刷（flush）和写（write），区分这两个概念（两个系统调用）是很重要的。
在大多数的操作系统中，把Innodb的log buffer（内存）写入日志（调用系统调用write），只是简单的把数据移到操作系统缓存中，
操作系统缓存同样指的是内存。并没有实际的持久化数据。
```
- 配置项 innodb_flush_log_at_trx_commit 用于控制 Log Buffer 如何写入和刷到磁盘。注意，除了 MySQL 的缓冲区，操作系统本身也有内核缓冲区。
    - 默认为1，表示每次事务提交都会将 Log Buffer 写入操作系统缓存，并调用配置的 “flush” 方法将数据写到磁盘。设置为 1 因为频繁刷磁盘效率会偏低，但是安全性高，最多丢失 1个 事务数据。
    - 为 0 则表示每秒才将 Log Buffer 写入内核缓冲区并调用 “flush” 方法将数据写到磁盘。
    ```
    mySQLd进程崩溃的时候，就会丢失最后1秒的事务
    ```
    - 为 2 则是每次事务提交都将 Log Buffer写入内核缓冲区，但是每秒才调用 “flush” 将内核缓冲区的数据刷到磁盘。
    ```
    只有在操作系统崩溃或者断电的时候才会丢失最后1秒的数据
    设置为 0 和 2 则可能丢失 1秒以上 的事务数据。
    ```

### Myisam
- Myisam 虽然不支持事务，但是再只读数据和可以忍受修复操作的情况下任然可以使用
- Myisam 支持压缩，并且设计简单，数据以紧密格式存储，所以性能很好
- 除了服务层定义的表结构外，还有XXX.myd 数据文件和XXX.myi 的索引文件(和innodb 不一样)

![image](AAFDF3B32AD24A558FC9FAFFE0839E1B)
- 将数据写到内存中，然后等待操作系统定时刷到磁盘上

#### 索引结构
- MyISAM使用B+树作为索引结构，叶节点的data域保存的是存储数据的地址，主键索引key值唯一，辅助索引key可以重复，二者在结构上相同。
- MyISAM使用B+树作为索引结构，叶节点叶节点的data域保存的是存储数据的地址，主键索引key值唯一，辅助索引key可以重复，二者在结构上相同。


#### 应用场景
- 配合 Merge 做数仓(合并)
- 日志应用,数据采集(插入速度快)
- 典型的读多写少的场景

### Archive 
- 只支持select 和 insert 操作，适用于数据采集——数据需要快速插入，然后在必要的时候进行数据分析——全表扫描
- 总之，它是一个针对高速插入(专用缓冲区)和压缩做了优化的引擎。
#### 应用场景
- 爬虫等数据采集
- 数据分析

### CSV
- CSV存储引擎可以将CSV文件作为MySQL表来处理，这种存储引擎的存储格式的就是普通的CSV文件
```
数据存储在MyISAM，或者说InnoDB表中的话，其数据文件我们是不能直接查看的，因为这两种存储引擎的数据存储都是以二进制文件方式来存储的。
```
- CSV存储引擎可以在数据库运行时，拷贝或者是拷出文件，存储数据的文件，可以将excel电子表格软件中的数据的存储为CSV文件，然后复制到MySQL数据目录下，就能够在MySQL中打开和使用了


```
CREATE TABLE user_behavior (
    user_id BIGINT not null,
    item_id BIGINT not null,
    category_id BIGINT not null,
    behavior varchar(10) not null,
    ts BIGINT not null
) engine=csv
```
![image](5ED3DCBEA774462090E66251CD89AF7C)

#### 应用场景
- 数据交换

### Memory 引擎
- MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。所以**性能上比Myisam 至少快一个数量级**
- 由于表结构是在服务层的，所以重启之后数据会丢失，但是表结构还在，正常情况下在数据目录里面也看不到数据文件，只能看到表结构文件
- MEMORY**默认使用哈希索引**。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。

#### 适用场景
- 用于查找或者映射表，例如区域和邮编的映射表
- 周期性缓存聚合数据
- 保存数据分析过程中产生的临时表

#### Memory引擎的退化
- tmp_table_size 和 max_heap_table_size 参数控制了Memory 引擎能使用的内存临时表的大小，如果隐式内存临时表的内存大小超过这个限制，将会被转换为磁盘Myisam表
- 隐式内存临时表是由引擎自己创建的，用来保存中间结果

### Merge 引擎
- Merge存储引擎允许将一组使用MyISAM存储引擎的并且表结构相同（即每张表的字段顺序、字段名称、字段类型、索引定义的顺序及其定义的方式必须相同）的数据表合并为一个表，方便了数据的查询。
#### 例子
- log_2004、log_2005、log_2006、log_2007 这四张日志记录表，其数据分别是每一年的数据表结构如下（YY代表年份）
```
CREATE TABLE log_YY (  
	  dt  DATETIME NOT NULL,  
	  info VARCHAR(100) NOT NULL,  
	  INDEX (dt)  
) ENGINE = MyISAM;
```
- 可以通过以下建表方式对上述的表进行合并
```

CREATE TABLE log_merge(  
	    dt DATETIME NOT NULL,  
	    info VARCHAR(100) NOT NULL,  
	    INDEX(dt)  
) ENGINE = MERGE UNION = (log_2004, log_2005, log_2006, log_2007);
```
- 该log_merge表创建成功后，就可以像普通表那样查询它，只是每一次查询都将同时作用于构成它的每一个成员数据表 。譬如查询这些日志数据表的数据行总数

#### 适用场景
- 日志应用
- 数仓应用

### 第三方引擎
- Mysql 从2007 年开始，提供了插件式的存储引擎API,从此出现了很对针对不同场景下的存储引擎
#### OLTP 引擎
#### 面向列式的存储引擎

### 存储引擎的转换
#### alter table 的方法
- 这种方法，会复制原表数据到新表，复制期间产生大量的磁盘IO,并且原表会上锁，存储引擎的转换会导致原有表的特性消失,例如外键等

#### 导入导出的方法

#### 查询和创建
- 新建一张表，指定查询引擎，然后将数据插入到这张表里，然后对原表和新表进行同时重命名


## 总结
1. InnoDB引擎，最重要，使用最广泛的存储引擎。被用来设计处理大量短期事务，具有高性能和自动崩溃恢复的特性。
2. MyISAM引擎，不支持事务和行级锁，崩溃后无法安全恢复。